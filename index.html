<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VibeMol — CUBE Isosurface Viewer</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121822;
      --text: #e8eef6;
      --muted: #9ab;
      --accent: #4aa3ff;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font: 14px/1.3 system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    #toolbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--panel);
      border-bottom: 1px solid #223;
      padding: 8px 10px;
      display: flex;
      gap: 12px;
      align-items: center;
      z-index: 10;
      flex-wrap: wrap;
    }

    #toolbar label {
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--muted);
    }

    #toolbar input[type="number"] {
      width: 6.5em;
    }

    #toolbar input[type="range"] {
      width: 140px;
    }

    #toolbar input[type="color"] {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
    }

    #toolbar button {
      background: var(--accent);
      color: #003;
      border: none;
      padding: 6px 10px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
    }

    #toolbar button.secondary {
      background: #2a3344;
      color: #dfe7f3;
    }

    #toolbar .spacer {
      flex: 1;
    }

    #drop {
      position: fixed;
      top: 56px;
      left: 0;
      right: 0;
      bottom: 0;
    }

    /* Side panel for dynamic info */
    #sidePanel {
      position: fixed;
      top: 56px;
      right: 0;
      bottom: 0;
      width: 320px;
      background: var(--panel);
      border-left: 1px solid #223;
      box-shadow: -6px 0 16px #0006;
      transform: translateX(100%);
      transition: transform 160ms ease-in-out;
      z-index: 20;
      display: flex;
      flex-direction: column;
    }

    #sidePanel.open {
      transform: translateX(0);
    }

    #sideHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid #223;
      color: var(--text);
    }

    #sideHeader .title {
      font-weight: 600;
    }

    #sideClose {
      background: #2a3344;
      color: #dfe7f3;
      border: none;
      padding: 4px 8px;
      border-radius: 6px;
      cursor: pointer;
    }

    #coordsContent {
      padding: 10px 12px;
      overflow: auto;
      color: var(--text);
      font-size: 13px;
    }

    #viewControls {
      padding: 10px 12px;
      border-bottom: 1px solid #223;
      color: var(--text);
      background: #0f151f;
    }

    #viewControls .row {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      gap: 6px;
      margin-bottom: 8px;
      align-items: center;
    }

    #viewControls .row-vec {
      display: grid;
      grid-template-columns: 60px 10px 1fr 10px 1fr 10px 1fr;
      gap: 4px;
      margin-bottom: 8px;
      align-items: center;
    }

    #viewControls label {
      color: var(--muted);
      font-size: 12px;
    }

    #viewControls input[type="number"] {
      width: 100%;
      padding: 3px 6px;
      background: #1a2230;
      color: var(--text);
      border: 1px solid #223;
      border-radius: 4px;
    }

    #viewControls input[type="checkbox"] {
      vertical-align: middle;
    }

    #viewControls .axis {
      color: var(--muted);
      font-size: 12px;
      text-align: center;
    }

    #coordsContent table {
      width: 100%;
      border-collapse: collapse;
    }

    #coordsContent th,
    #coordsContent td {
      text-align: right;
      padding: 4px 6px;
      border-bottom: 1px solid #223;
    }

    #coordsContent th {
      text-align: left;
      color: var(--muted);
      font-weight: 600;
    }

    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #fileInput {
      display: none;
    }

    #hint {
      position: fixed;
      left: 12px;
      bottom: 10px;
      color: #9ab;
      background: #0f141d90;
      padding: 6px 8px;
      border-radius: 6px;
    }
  </style>
</head>

<body>
  <div id="toolbar">
    <label><strong>CUBE/XYZ files</strong>
      <input type="file" id="fileInput" accept=".cube,.cub,.xyz" multiple />
      <button id="openBtn" class="secondary">Open…</button>
    </label>
    <label>Active file
      <select id="fileSelect"></select>
    </label>
    <label>Iso
      <input type="number" id="iso" value="0.02" step="0.005" />
    </label>
    <label>Opacity
      <input type="range" id="opacity" min="0.05" max="1" step="0.01" value="1.00" />
    </label>
    <label>+ color <input type="color" id="posColor" value="#f2a900" /></label>
    <label>− color <input type="color" id="negColor" value="#0033a0" /></label>
    <label>BG <input type="color" id="bgColor" value="#ffffff" /></label>
    <label><input type="checkbox" id="showAtoms" checked /> atoms</label>
    <label><input type="checkbox" id="showBonds" checked /> bonds</label>
    <label><input type="checkbox" id="elementColors" checked /> elem colors</label>
    <label><input type="checkbox" id="showBox" /> box</label>
    <label><input type="checkbox" id="showAxes" checked /> axes</label>
    <div class="spacer"></div>
    <button id="saveBtn" title="Save the current view as a PNG image">Save PNG</button>
    <button id="batchBtn" class="secondary" title="Export all views as PNG images">Batch export</button>
    <button id="surfBtn" class="secondary" title="Toggle iso-surface rendering">Hide Surfaces</button>
    <button id="clearBtn" class="secondary" title="Clear all loaded cubes">Clear</button>
    <button id="panelBtn" class="secondary" title="View and coordinates">View/Coords</button>
    <button id="helpBtn" class="secondary" title="Help and shortcuts">Help</button>
  </div>

  <div id="drop">
    <canvas id="canvas"></canvas>
  </div>
  <div id="hint">Drag & drop .cube or .xyz files here • Orbit: mouse drag • Zoom: wheel • Pan: right-drag</div>

  <!-- Right side panel (toggle) -->
  <div id="sidePanel" aria-hidden="true">
    <div id="sideHeader">
      <div class="title">View</div>
      <div>
        <button id="viewReset" class="secondary" title="Reset the view to the initial state">Reset View</button>
        <button id="sideClose" title="Close">✕</button>
      </div>
    </div>

    <div id="viewControls">
      <div class="row-vec">
        <label>Shift</label>
        <span class="axis">X</span><input type="number" id="shiftX" step="0.1"
          title="Shift the molecule in the X-direction" />
        <span class="axis">Y</span><input type="number" id="shiftY" step="0.1"
          title="Shift the molecule in the Y-direction" />
        <span class="axis">Z</span><input type="number" id="shiftZ" step="0.1"
          title="Shift the molecule in the Z-direction" />
      </div>
      <div class="row-vec">
        <label>Cam</label>
        <span class="axis">X</span><input type="number" id="camX" step="0.1"
          title="Camera position in the X-direction" />
        <span class="axis">Y</span><input type="number" id="camY" step="0.1"
          title="Camera position in the Y-direction" />
        <span class="axis">Z</span><input type="number" id="camZ" step="0.1"
          title="Camera position in the Z-direction" />
      </div>
      <div class="row-vec">
        <label>Target</label>
        <span class="axis">X</span><input type="number" id="tgtX" step="0.1"
          title="Target position in the X-direction" />
        <span class="axis">Y</span><input type="number" id="tgtY" step="0.1"
          title="Target position in the Y-direction" />
        <span class="axis">Z</span><input type="number" id="tgtZ" step="0.1"
          title="Target position in the Z-direction" />
      </div>
      <div class="row">
        <label>Rotate speed</label><input type="number" id="rotSpeed" step="0.01"
          title="Speed at which the view rotates" />
        <label>Damping</label><input type="number" id="damp" step="0.01" title="Damping factor for the view rotation" />
      </div>
      <div class="row">
        <label style="width:100px"><input type="checkbox" id="autoRot" title="Toggle auto rotation of the camera" />
          Auto-rotate</label>
        <label>Speed</label><input type="number" id="autoRotSpeed" step="1" title="Speed of auto-rotation" />
      </div>
      <div class="row">
        <label style="width: 80px;">Color scheme</label>
        <select id="schemeSelect" title="Choose default +/- surface colors">
          <option value="emory" selected>Emory (gold/blue)</option>
          <option value="national">National (red/blue)</option>
          <option value="bright">Bright (yellow/cyan)</option>
          <option value="electron">Electron (magenta/green)</option>
          <option value="classic">Classic (blue/red)</option>
          <option value="custom">Custom (via color pickers)</option>
        </select>
        <span></span><span></span>
      </div>
      <div class="row">
        <label style="width: 80px;">Render mode</label>
        <select id="renderMode" title="Choose visualization mode">
          <option value="surface" selected>Surfaces</option>
          <option value="cloud">Cloud</option>
        </select>
        <span></span><span></span>
      </div>
      <div class="row">
        <label>FPS</label>
        <div id="fpsValue" style="font-variant-numeric: tabular-nums; color: var(--muted);">--</div>
        <span></span><span></span>
      </div>
      <div class="row" id="rowStyle">
        <label style="width: 80px;">Surface style</label>
        <select id="styleSelect" title="Choose iso-surface material style">
          <option value="emissive" selected>Emissive (physical)</option>
          <option value="glass">Glass (physical)</option>
        </select>
        <span></span><span></span>
      </div>
      <div class="row" id="rowCloudType">
        <label style="width: 80px;">Cloud type</label>
        <select id="cloudType" title="Cloud renderer">
          <option value="cubes" selected>Cubes</option>
          <option value="points">Points</option>
        </select>
        <span></span><span></span>
      </div>
      <div class="row" id="rowCloudParams">
        <label style="width: 80px;">Stride</label><input type="number" id="cloudStride" min="1" max="8" step="1"
          value="1" title="Sample every N voxels per axis" />
        <label>Alpha max</label><input type="number" id="cloudAlpha" min="0.025" max="1" step="0.025" value="0.1" />
      </div>
    </div>
    <div id="sideHeader">
      <div class="title">Coordinates (Å)</div>
      <div>
        <button id="copyXYZ" class="secondary" title="Copy XYZ">Copy</button>
        <button id="downloadXYZ" class="secondary" title="Download XYZ">Download</button>
      </div>
    </div>
    <div id="coordsContent">
      <!-- Filled dynamically -->
    </div>
  </div>

  <!-- Help / Shortcuts modal -->
  <div id="helpOverlay" aria-hidden="true"
    style="display:none; position:fixed; inset:0; background:#0008; z-index:50; align-items:center; justify-content:center;">
    <div id="helpModal" role="dialog" aria-modal="true"
      style="background:var(--panel); color:var(--text); width:min(680px,92vw); max-height:80vh; overflow:auto; border:1px solid #223; border-radius:10px; box-shadow:0 10px 30px #000a;">
      <div
        style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid #223;">
        <div style="font-weight:700;">Help & Shortcuts</div>
        <button id="helpClose" class="secondary" title="Close">✕</button>
      </div>
      <div style="padding:12px 14px; font-size:13px; line-height:1.45;">
        <p>Tips</p>
        <ul>
          <li>Orbit: mouse drag • Zoom: wheel • Pan: right-drag</li>
          <li>Use View/Coords to adjust camera, target, and scene shift.</li>
          <li>Atoms and Bonds can be toggled independently; bonds are color‑graded between atoms.</li>
          <li>The Cartesian coordinates are displayed as red (X), green (Y), and blue (Z) arrows.</li>
        </ul>
        <p>Shortcuts</p>
        <ul>
          <li><strong>S</strong> — Save PNG</li>
          <li><strong>B</strong> — Batch export all files</li>
          <li><strong>I</strong> — Toggle iso‑surfaces on/off</li>
          <li><strong>X</strong> — Toggle axis gizmo on/off</li>
          <li><strong>←/→</strong> or <strong>↑/↓</strong> — Previous / Next file (view preserved)</li>
          <li><strong>Esc</strong> — Close open menus/dialogs</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- three.js core and controls (local copies) -->
  <script src="./three.min.js"></script>
  <script src="./OrbitControls.global.js"></script>
  <!-- isosurface (global) -->
  <script src="isosurface.bundle.js"></script>
  <!-- atomic data (global) -->
  <script src="atomicData.js"></script>

  <script>
    (function () {
      // --- Constants & helpers ---
      const BOHR_TO_ANG = 0.529177210903;

      function arrayMinMax(a) {
        let min = Infinity, max = -Infinity;
        for (let i = 0; i < a.length; i++) {
          const v = a[i];
          if (v < min) min = v;
          if (v > max) max = v;
        }
        return { min, max };
      }

      function parseCube(text) {
        // Split lines, handle CRLF
        const lines = text.replace(/\r/g, '').split('\n');

        if (lines.length < 6) throw new Error("Not enough lines for a CUBE file.");

        const title = lines[0];
        const comment = lines[1];

        // Generic "(x,y)" capture anywhere on the 2nd line (your regex)
        let isoHint = null;
        {
          const m = comment.match(/\(([-+]?\d*\.?\d+(?:[eE][+-]?\d+)?)\s*,\s*([-+]?\d*\.?\d+(?:[eE][+-]?\d+)?)\)/);
          if (m) isoHint = parseFloat(m[1]); // take the first number as suggested level
        }

        // natoms / origin line
        const L3 = lines[2].trim().split(/\s+/);
        const natoms = parseInt(L3[0], 10);
        const origin = [parseFloat(L3[1]), parseFloat(L3[2]), parseFloat(L3[3])];

        // grid counts + per-voxel step vectors (Bohr)
        const sx = lines[3].trim().split(/\s+/).map(Number); // [numx, ax, ay, az]
        const sy = lines[4].trim().split(/\s+/).map(Number); // [numy, bx, by, bz]
        const sz = lines[5].trim().split(/\s+/).map(Number); // [numz, cx, cy, cz]
        const numx = Math.abs(sx[0]) | 0, numy = Math.abs(sy[0]) | 0, numz = Math.abs(sz[0]) | 0;
        const ax = sx.slice(1, 4); // per-voxel step along i
        const ay = sy.slice(1, 4); // per-voxel step along j
        const az = sz.slice(1, 4); // per-voxel step along k

        // atoms: Z, q, x, y, z  (positions in Bohr)
        const atoms = [];
        for (let i = 0; i < Math.abs(natoms); i++) {
          const p = lines[6 + i].trim().split(/\s+/).map(Number);
          atoms.push({ Z: p[0], q: p[1], x: p[2], y: p[3], z: p[4] });
        }

        // volumetric data (z fastest, then y, then x) — reshape (numx,numy,numz)
        const flat = lines.slice(6 + Math.abs(natoms)).join(' ').trim().split(/\s+/);
        const total = numx * numy * numz;
        if (flat.length < total) throw new Error(`Data size mismatch. Expected ${total}, got ${flat.length}`);
        const data = new Float32Array(total);
        for (let i = 0; i < total; i++) data[i] = parseFloat(flat[i]);

        // index helper matching your reshape: data[i,j,k]
        const idx = (i, j, k) => (i * numy + j) * numz + k;

        return {
          title, comment,
          natoms: Math.abs(natoms),
          origin,                        // Bohr
          nxyz: [numx, numy, numz],
          axes: [ax, ay, az],            // per-voxel step vectors in Bohr
          atoms, data, idx,
          units: 'bohr',                 // positions stored in Bohr
          isoHint                        // may be null if not present
        };
      }

      function parseXYZ(text) {
        const lines = text.replace(/\r/g, '').split('\n');
        let i = 0;
        // Optional first line atom count
        let natoms = 0;
        if (lines.length > 0) {
          const maybeN = parseInt((lines[0] || '').trim(), 10);
          if (!Number.isNaN(maybeN) && maybeN >= 0) {
            natoms = maybeN | 0; i = 2; // skip count + optional comment
          }
        }
        const atoms = [];
        for (; i < lines.length; i++) {
          const l = lines[i].trim();
          if (!l) continue;
          const parts = l.split(/\s+/);
          if (parts.length < 4) continue;
          const sym = parts[0];
          const Z = (window.ATOM_SYMBOL_TO_Z && window.ATOM_SYMBOL_TO_Z[sym.toUpperCase()]) || 0;
          const x = parseFloat(parts[1]);
          const y = parseFloat(parts[2]);
          const z = parseFloat(parts[3]);
          if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z)) {
            atoms.push({ Z, q: 0, x, y, z }); // XYZ is in Å already
          }
        }
        if (natoms === 0) natoms = atoms.length;
        const idx = (i, j, k) => 0;
        return { title: 'XYZ', comment: '', natoms, origin:[0,0,0], nxyz:[0,0,0], axes:[[1,0,0],[0,1,0],[0,0,1]], atoms, data:new Float32Array(0), idx, units: 'angstrom', kind: 'xyz' };
      }

      // (subsample removed)

      // Map a point in voxel grid coords (x,y,z in [0..nx-1], etc.) to world (Å)
      function voxelToWorld(vol, p) {
        const a = vol.axes[0].map(v => v * BOHR_TO_ANG);
        const b = vol.axes[1].map(v => v * BOHR_TO_ANG);
        const c = vol.axes[2].map(v => v * BOHR_TO_ANG);
        const o = vol.origin ? vol.origin.map(v => v * BOHR_TO_ANG) : [0, 0, 0];
        return [
          o[0] + p[0] * a[0] + p[1] * b[0] + p[2] * c[0],
          o[1] + p[0] * a[1] + p[1] * b[1] + p[2] * c[1],
          o[2] + p[0] * a[2] + p[1] * b[2] + p[2] * c[2],
        ];
      }

      function makeIsosurface(vol, level) {
        const [nx, ny, nz] = vol.nxyz;
        // MarchingCubes extracts the 0-level set of the potential.
        // To get an iso-surface at `level`, return field(x)-level.
        const sampler = (x, y, z) => {
          const i = Math.max(0, Math.min(nx - 1, Math.floor(x)));
          const j = Math.max(0, Math.min(ny - 1, Math.floor(y)));
          const k = Math.max(0, Math.min(nz - 1, Math.floor(z)));
          return vol.data[vol.idx(i, j, k)];
        };
        // Marching cubes → triangles (no explicit bounds => defaults to [[0,0,0],[nx,ny,nz]])
        const result = isosurface.marchingCubes([nx, ny, nz], (x, y, z) => sampler(x, y, z) - level);

        // Weld vertices across cube boundaries by deduplicating identical voxel-space positions.
        // Quantize voxel coords to a small grid to ensure stable keys.
        const voxPos = result.positions; // array of [x,y,z] in voxel units
        const key = (p) => `${Math.round(p[0] * 1e6)},${Math.round(p[1] * 1e6)},${Math.round(p[2] * 1e6)}`;
        const map = new Map();
        const unique = [];
        const oldToNew = new Uint32Array(voxPos.length);
        for (let i = 0; i < voxPos.length; i++) {
          const k = key(voxPos[i]);
          let idx = map.get(k);
          if (idx === undefined) {
            idx = unique.length;
            map.set(k, idx);
            unique.push(voxPos[i]);
          }
          oldToNew[i] = idx;
        }

        // Remap triangle indices through the welding map
        const cells = result.cells; // array of [a,b,c]
        const indices = new Uint32Array(cells.length * 3);
        for (let t = 0; t < cells.length; t++) {
          const c = cells[t];
          indices[3 * t + 0] = oldToNew[c[0]];
          indices[3 * t + 1] = oldToNew[c[1]];
          indices[3 * t + 2] = oldToNew[c[2]];
        }

        // Build world-space positions for the unique vertices
        const positions = new Float32Array(unique.length * 3);
        for (let i = 0; i < unique.length; i++) {
          const p = voxelToWorld(vol, unique[i]); // map voxel coords to Å
          positions[3 * i + 0] = p[0];
          positions[3 * i + 1] = p[1];
          positions[3 * i + 2] = p[2];
        }

        const geom = new THREE.BufferGeometry();
        geom.setIndex(new THREE.BufferAttribute(indices, 1));
        geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geom.computeVertexNormals();
        return geom;
      }

      // --- Three.js scene setup ---
      const canvas = document.getElementById('canvas');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });
      renderer.autoClear = false; // allow overlay rendering in same canvas
      const scene = new THREE.Scene();
      // Default to white background
      scene.background = new THREE.Color(0xffffff);
      const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 1e6);
      camera.position.set(60, 50, 60);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      // Default rotate speed
      controls.rotateSpeed = 1.5;

      // Lights
      const hemi = new THREE.HemisphereLight(0xffffff, 0x081018, 2.0);
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(1, 1, 1);
      const amb = new THREE.AmbientLight(0x999999, 0.65);
      scene.add(hemi, dir, amb);

      // Resizer
      function resize() {
        const panelH = 56; // toolbar height
        const w = window.innerWidth;
        const h = window.innerHeight - panelH;
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', resize);
      resize();

      // --- Corner axes (overlay) ---
      const axisScene = new THREE.Scene();
      // Use an orthographic camera so the gizmo stays centered without perspective shift
      const axisCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
      axisCamera.position.set(0, 0, 2);
      axisCamera.lookAt(0, 0, 0);
      const axisGizmo = new THREE.Group();
      // Simple lights so the gizmo shows shaded heads/shafts
      {
        const aHemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.9);
        const aDir = new THREE.DirectionalLight(0xffffff, 1.2); aDir.position.set(1, 1, 1);
        axisScene.add(aHemi, aDir);
      }
      function addShadedArrow(dir, color) {
        const g = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.35, metalness: 0.15 });
        // Shaft along +Y
        const shaftLen = 0.75, shaftRad = 0.05;
        const shaft = new THREE.Mesh(new THREE.CylinderGeometry(shaftRad, shaftRad, shaftLen, 16, 1), mat);
        shaft.position.y = shaftLen / 2;
        g.add(shaft);
        // Head (cone) along +Y
        const headLen = 0.30, headRad = 0.12;
        const head = new THREE.Mesh(new THREE.ConeGeometry(headRad, headLen, 20, 1), mat);
        head.position.y = shaftLen + headLen / 2;
        g.add(head);
        // Rotate to desired direction
        const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());
        g.setRotationFromQuaternion(q);
        axisGizmo.add(g);
      }
      addShadedArrow(new THREE.Vector3(1, 0, 0), 0xff4136); // X - red
      addShadedArrow(new THREE.Vector3(0, 1, 0), 0x2ecc40); // Y - green
      addShadedArrow(new THREE.Vector3(0, 0, 1), 0x0074d9); // Z - blue
      axisScene.add(axisGizmo);

      // State
      let volumes = []; // {name, vol}
      let currentIndex = -1;
      let meshes = []; // active meshes (pos/neg)
      let atomGroup = new THREE.Group();
      let bondGroup = new THREE.Group();
      let cloudGroup = new THREE.Group();
      let boxHelper = null;
      let showSurfaces = true; // toggle iso-surface visibility
      // Default view reference (captured on first non-preserved fit)
      let defaultView = null;
      // Current iso-surface material style
      let surfaceStyle = 'emissive';
      // Content group to allow whole-scene shifting
      const contentGroup = new THREE.Group();
      scene.add(contentGroup);
      contentGroup.add(atomGroup);
      contentGroup.add(bondGroup);
      contentGroup.add(cloudGroup);

      function clearSceneMeshes() {
        for (const m of meshes) contentGroup.remove(m), m.geometry.dispose(), m.material.dispose();
        meshes = [];
        // Reset atom and bond groups
        contentGroup.remove(atomGroup); atomGroup.clear(); atomGroup = new THREE.Group();
        contentGroup.remove(bondGroup); bondGroup.clear(); bondGroup = new THREE.Group();
        contentGroup.remove(cloudGroup); cloudGroup.clear(); cloudGroup = new THREE.Group();
        if (boxHelper) { contentGroup.remove(boxHelper); boxHelper.geometry.dispose(); boxHelper.material.dispose(); boxHelper = null; }
      }

      function buildAtoms(vol) {
        const group = new THREE.Group();
        // Atoms (spheres)
        const sphere = new THREE.SphereGeometry(0.5, 20, 12);
        // Covalent radii from atomic data (Å)
        const covR = (z) => (ATOM_Z_TO_DATA && ATOM_Z_TO_DATA[z] && ATOM_Z_TO_DATA[z].radius_covalent) || 0.70;
        const atomPositions = [];
        const toAng = (vol.units === 'angstrom');
        for (const a of vol.atoms) {
          const r = covR(a.Z | 0);
          // Element-based color if enabled
          let atomColor = new THREE.Color(0xffffff);
          if (typeof elementColors !== 'undefined' && elementColors && elementColors.checked && ATOM_Z_TO_DATA) {
            const info = ATOM_Z_TO_DATA[a.Z | 0];
            if (info && Array.isArray(info.color)) {
              const [cr, cg, cb] = info.color;
              atomColor = new THREE.Color(cr / 255, cg / 255, cb / 255);
            }
          }
          const mat = new THREE.MeshStandardMaterial({ color: atomColor, roughness: 0.25, metalness: 0.25 });
          const mesh = new THREE.Mesh(sphere, mat);
          const px = toAng ? a.x : a.x * BOHR_TO_ANG;
          const py = toAng ? a.y : a.y * BOHR_TO_ANG;
          const pz = toAng ? a.z : a.z * BOHR_TO_ANG;
          const pos = new THREE.Vector3(px, py, pz);
          mesh.position.copy(pos);
          mesh.scale.setScalar(r * 1.2);
          group.add(mesh);
          atomPositions.push({ pos, Z: a.Z | 0 });
        }
        return group;
      }

      function buildBonds(vol) {
        const group = new THREE.Group();
        const covR = (z) => (ATOM_Z_TO_DATA && ATOM_Z_TO_DATA[z] && ATOM_Z_TO_DATA[z].radius_covalent) || 0.70;
        const atomPositions = [];
        const toAng = (vol.units === 'angstrom');
        for (const a of vol.atoms) {
          const px = toAng ? a.x : a.x * BOHR_TO_ANG;
          const py = toAng ? a.y : a.y * BOHR_TO_ANG;
          const pz = toAng ? a.z : a.z * BOHR_TO_ANG;
          const pos = new THREE.Vector3(px, py, pz);
          atomPositions.push({ pos, Z: a.Z | 0 });
        }
        const bondMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.1, metalness: 0.1 });
        const up = new THREE.Vector3(0, 1, 0);
        const N = atomPositions.length;
        const bondRadius = 0.12; // Å
        for (let i = 0; i < N; i++) {
          for (let j = i + 1; j < N; j++) {
            const a = atomPositions[i];
            const b = atomPositions[j];
            const ri = covR(a.Z);
            const rj = covR(b.Z);
            const cutoff = 1.15 * (ri + rj); // heuristic
            const dir = new THREE.Vector3().subVectors(b.pos, a.pos);
            const len = dir.length();
            if (len < 0.4 || len > cutoff) continue;
            const mid = new THREE.Vector3().addVectors(a.pos, b.pos).multiplyScalar(0.5);
            const geom = new THREE.CylinderGeometry(bondRadius, bondRadius, len, 12, 1, false);
            const cyl = new THREE.Mesh(geom, bondMat);
            cyl.position.copy(mid);
            const q = new THREE.Quaternion().setFromUnitVectors(up, dir.normalize());
            cyl.setRotationFromQuaternion(q);
            group.add(cyl);
          }
        }
        return group;
      }

      function buildBox(vol) {
        const [nx, ny, nz] = vol.nxyz;
        // Use cell-corner indexing: far corner at (nx,ny,nz) works visually, but try (nx-1,...) to stay within data
        const nx1 = Math.max(0, nx - 1), ny1 = Math.max(0, ny - 1), nz1 = Math.max(0, nz - 1);
        const corners = [
          [0, 0, 0], [nx1, 0, 0], [0, ny1, 0], [0, 0, nz1],
          [nx1, ny1, 0], [nx1, 0, nz1], [0, ny1, nz1], [nx1, ny1, nz1]
        ].map(p => new THREE.Vector3(...voxelToWorld(vol, p)));
        const geom = new THREE.BufferGeometry();
        const verts = new Float32Array(24 * 3);
        const edges = [
          [0, 1], [0, 2], [0, 3], [7, 6], [7, 5], [7, 4], [1, 4], [1, 5], [2, 4], [2, 6], [3, 5], [3, 6]
        ];
        edges.forEach((e, i) => {
          verts[6 * i + 0] = corners[e[0]].x; verts[6 * i + 1] = corners[e[0]].y; verts[6 * i + 2] = corners[e[0]].z;
          verts[6 * i + 3] = corners[e[1]].x; verts[6 * i + 4] = corners[e[1]].y; verts[6 * i + 5] = corners[e[1]].z;
        });
        geom.setAttribute('position', new THREE.BufferAttribute(verts, 3));
        const mat = new THREE.LineBasicMaterial({ color: 0xd3d3d3, linewidth: 1, depthTest: false, transparent: true, opacity: 0.9 });
        return new THREE.LineSegments(geom, mat);
      }

      // --- Surface material helpers ---
      function createIsoMaterial(sign, opacity) {
        const col = new THREE.Color(sign === 'neg' ? negColor.value : posColor.value);
        if (surfaceStyle === 'glass') {
          col.multiplyScalar(2);
          return new THREE.MeshPhysicalMaterial({
            color: col,
            transmission: 1.0,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 0.8,
            clearcoatRoughness: 0.025,
            reflectivity: 0.1,
            ior: 1.2,
            thickness: 1.0,
            side: THREE.DoubleSide,
          });
        }
        if (surfaceStyle === 'emissive') {
          return new THREE.MeshPhysicalMaterial({
            color: col,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            emissive: col.clone(),
            emissiveIntensity: 0.8,
            side: THREE.DoubleSide,
            transparent: true,
            opacity
          });
        }
        // Fallback standard
        return new THREE.MeshStandardMaterial({ color: col, roughness: 0.4, metalness: 0.05, side: THREE.DoubleSide, transparent: true, opacity });
      }

      // --- Cloud builders ---
      function voxelCenterToWorld(vol, i, j, k) {
        // position at cell center: (i+0.5, j+0.5, k+0.5)
        return voxelToWorld(vol, [i + 0.5, j + 0.5, k + 0.5]);
      }

      function estimateCellSize(vol) {
        // average step magnitude in Å
        const ax = vol.axes[0].map(v => v * BOHR_TO_ANG);
        const ay = vol.axes[1].map(v => v * BOHR_TO_ANG);
        const az = vol.axes[2].map(v => v * BOHR_TO_ANG);
        const len = v => Math.hypot(v[0], v[1], v[2]);
        return (len(ax) + len(ay) + len(az)) / 3;
      }

      function absPercentile(vol, p, stride) {
        const [nx, ny, nz] = vol.nxyz;
        const step = Math.max(1, stride | 0);
        const arr = [];
        for (let i = 0; i < nx; i += step) {
          for (let j = 0; j < ny; j += step) {
            for (let k = 0; k < nz; k += step) {
              const v = Math.abs(vol.data[vol.idx(i, j, k)]);
              arr.push(v);
            }
          }
        }
        if (arr.length === 0) return 0;
        arr.sort((a, b) => a - b);
        const idx = Math.min(arr.length - 1, Math.max(0, Math.floor(p * (arr.length - 1))));
        return arr[idx];
      }

      function buildCloudCubes(vol, opts) {
        const g = new THREE.Group();
        const [nx, ny, nz] = vol.nxyz;
        const stride = Math.max(1, opts.stride | 0);
        // Compute voxel edge lengths in Å and scale so adjacent samples touch.
        const ax = vol.axes[0].map(v => v * BOHR_TO_ANG);
        const ay = vol.axes[1].map(v => v * BOHR_TO_ANG);
        const az = vol.axes[2].map(v => v * BOHR_TO_ANG);
        const len = v => Math.hypot(v[0], v[1], v[2]);
        const scaleVec = new THREE.Vector3(len(ax) * stride, len(ay) * stride, len(az) * stride);
        // Determine high bound
        const hi = opts.hiMode === 'max' ? Math.max(...vol.data.map(v => Math.abs(v))) : absPercentile(vol, 0.99, Math.max(1, stride));
        const tLow = opts.tLow;
        const clamp01 = x => Math.max(0, Math.min(1, x));
        // Count instances per sign
        let nPos = 0, nNeg = 0;
        for (let i = 0; i < nx; i += stride) {
          for (let j = 0; j < ny; j += stride) {
            for (let k = 0; k < nz; k += stride) {
              const v = vol.data[vol.idx(i, j, k)];
              const av = Math.abs(v);
              if (av < tLow) continue;
              if (v >= 0) nPos++; else nNeg++;
            }
          }
        }
        const makeInst = (count, color) => {
          const geom = new THREE.BoxGeometry(1, 1, 1);
          const alpha = Math.min(1, opts.alphaMax * stride);
          const mat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(color),
            transparent: alpha < 1.0,
            opacity: alpha,
            depthWrite: alpha >= 1.0,
            depthTest: true,
            dithering: true,
            polygonOffset: true,
            polygonOffsetFactor: -0.5,
            polygonOffsetUnits: -1.0,
          });
          return new THREE.InstancedMesh(geom, mat, Math.max(1, count));
        };
        const instPos = makeInst(nPos, posColor.value); instPos.userData.sign = 'pos';
        const instNeg = makeInst(nNeg, negColor.value); instNeg.userData.sign = 'neg';
        let ip = 0, ineg = 0;
        const m4 = new THREE.Matrix4();
        const q = new THREE.Quaternion();
        const s = new THREE.Vector3();
        for (let i = 0; i < nx; i += stride) {
          for (let j = 0; j < ny; j += stride) {
            for (let k = 0; k < nz; k += stride) {
              const v = vol.data[vol.idx(i, j, k)];
              const av = Math.abs(v);
              if (av < tLow) continue;
              const pos = voxelCenterToWorld(vol, i, j, k);
              // Slightly shrink to mitigate coplanar z-fighting while still appearing contiguous
              m4.compose(new THREE.Vector3(pos[0], pos[1], pos[2]), q.identity(), s.copy(scaleVec).multiplyScalar(0.99));
              if (v >= 0) { instPos.setMatrixAt(ip++, m4); }
              else { instNeg.setMatrixAt(ineg++, m4); }
            }
          }
        }
        instPos.instanceMatrix.needsUpdate = true;
        instNeg.instanceMatrix.needsUpdate = true;
        g.add(instPos, instNeg);
        return g;
      }

      function buildCloudPoints(vol, opts) {
        const g = new THREE.Group();
        const [nx, ny, nz] = vol.nxyz;
        const stride = Math.max(1, opts.stride | 0);
        const tLow = opts.tLow;
        // Determine hi bound for strength mapping
        const hi = absPercentile(vol, 0.99, Math.max(1, stride));
        const clamp01 = x => Math.max(0, Math.min(1, x));
        // Collect positions and strength per sign
        const posPos = [], posNeg = [], strPos = [], strNeg = [];
        for (let i = 0; i < nx; i += stride) {
          for (let j = 0; j < ny; j += stride) {
            for (let k = 0; k < nz; k += stride) {
              const v = vol.data[vol.idx(i, j, k)];
              const av = Math.abs(v);
              if (av < tLow) continue;
              const s = clamp01((av - tLow) / Math.max(1e-12, (hi - tLow)));
              const p = voxelCenterToWorld(vol, i, j, k);
              if (v >= 0) { posPos.push(p[0], p[1], p[2]); strPos.push(s); }
              else { posNeg.push(p[0], p[1], p[2]); strNeg.push(s); }
            }
          }
        }
        // Shader material for round, shaded sprites
        const baseSize = estimateCellSize(vol) * 12.0; // uniform size, independent of stride/strength
        const makeSpriteMat = (colorHex) => new THREE.ShaderMaterial({
          uniforms: {
            uColor: { value: new THREE.Color(colorHex) },
            uAlpha: { value: Math.min(1.0, opts.alphaMax * stride) },
            uSize: { value: baseSize },
          },
          vertexShader: `
            uniform float uSize;
            attribute float aStrength;
            varying float vStrength;
            void main() {
              vStrength = aStrength;
              vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
              // approximate size attenuation (constant base size)
              float dist = -mvPosition.z;
              gl_PointSize = uSize * (300.0 / max(1.0, dist));
              gl_Position = projectionMatrix * mvPosition;
            }
          `,
          fragmentShader: `
            uniform vec3 uColor;
            uniform float uAlpha;
            varying float vStrength;
            void main() {
              vec2 uv = gl_PointCoord - vec2(0.5);
              float d = length(uv);
              if (d > 0.5) discard; // round sprite
              float fall = smoothstep(0.5, 0.0, d);
              float a = uAlpha * vStrength * fall;
              gl_FragColor = vec4(uColor, a);
            }
          `,
          transparent: true,
          depthWrite: false,
          depthTest: false,
          blending: THREE.NormalBlending,
        });
        const makePoints = (posArr, strArr, color, sign) => {
          const geo = new THREE.BufferGeometry();
          geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(posArr), 3));
          geo.setAttribute('aStrength', new THREE.BufferAttribute(new Float32Array(strArr), 1));
          const mat = makeSpriteMat(color);
          const pts = new THREE.Points(geo, mat);
          pts.userData.sign = sign;
          return pts;
        };
        if (posPos.length) g.add(makePoints(posPos, strPos, posColor.value, 'pos'));
        if (posNeg.length) g.add(makePoints(posNeg, strNeg, negColor.value, 'neg'));
        return g;
      }

      function fitCameraToScene() {
        const box = new THREE.Box3();
        let hasSomething = false;
        for (const m of meshes) { box.expandByObject(m); hasSomething = true; }
        if (atomGroup.children.length) { box.expandByObject(atomGroup); hasSomething = true; }
        if (bondGroup.children.length) { box.expandByObject(bondGroup); hasSomething = true; }
        if (boxHelper) { box.expandByObject(boxHelper); hasSomething = true; }
        if (!hasSomething || box.isEmpty()) return;

        const size = new THREE.Vector3(), center = new THREE.Vector3();
        box.getSize(size); box.getCenter(center);
        const maxDim = Math.max(size.x, size.y, size.z);
        // Tighten fit so the model appears ~1.75x larger
        const FIT_TIGHTNESS = 1.6 / 1.75;
        const dist = maxDim * FIT_TIGHTNESS / Math.tan((camera.fov * Math.PI / 180) / 2);
        const dir = new THREE.Vector3(1, 1, 1).normalize();
        camera.position.copy(center.clone().add(dir.multiplyScalar(dist)));
        camera.near = Math.max(0.01, dist / 100);
        camera.far = dist * 10 + maxDim;
        camera.updateProjectionMatrix();
        controls.target.copy(center);
        controls.update();
      }

      // Simple FPS meter (EMA smoothed)
      let __fpsLast = performance.now();
      let __fpsAccMs = 0;
      let __fpsFrames = 0;
      let __fpsEMA = 0;

      function render() {
        controls.update();

        // Main scene
        renderer.clear();
        renderer.setViewport(0, 0, renderer.domElement.width, renderer.domElement.height);
        renderer.setScissorTest(false);
        renderer.render(scene, camera);

        // FPS update
        const now = performance.now();
        const dt = now - __fpsLast; __fpsLast = now;
        __fpsAccMs += dt; __fpsFrames += 1;
        if (__fpsAccMs >= 500) {
          const inst = (__fpsFrames * 1000) / __fpsAccMs;
          __fpsEMA = (__fpsEMA === 0) ? inst : (__fpsEMA * 0.8 + inst * 0.2);
          const el = document.getElementById('fpsValue');
          if (el) el.textContent = __fpsEMA.toFixed(1);
          __fpsAccMs = 0; __fpsFrames = 0;
        }

        // Overlay axes (bottom-left) — only if enabled
        if (window.__showAxes__) {
          // Copy view rotation only by rotating the gizmo opposite the camera
          // so it reflects world-axis orientation in the current view.
          axisGizmo.quaternion.copy(camera.quaternion).invert();
          const size = new THREE.Vector2();
          renderer.getSize(size);
          const px = Math.max(64, Math.min(128, Math.floor(Math.min(size.x, size.y) / 5)));
          const margin = 10;
          renderer.clearDepth();
          renderer.setScissorTest(true);
          renderer.setScissor(margin, margin, px, px);
          renderer.setViewport(margin, margin, px, px);
          // Orthographic camera has fixed framing; no aspect update needed
          renderer.render(axisScene, axisCamera);
        }

        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);

      // --- UI wiring ---
      const fileInput = document.getElementById('fileInput');
      const openBtn = document.getElementById('openBtn');
      const fileSelect = document.getElementById('fileSelect');
      const isoInput = document.getElementById('iso');
      const opInput = document.getElementById('opacity');
      const posColor = document.getElementById('posColor');
      const negColor = document.getElementById('negColor');
      const bgColor = document.getElementById('bgColor');
      const toggleAtoms = document.getElementById('showAtoms');
      const toggleBonds = document.getElementById('showBonds');
      const elementColors = document.getElementById('elementColors');
      const toggleBox = document.getElementById('showBox');
      const toggleAxes = document.getElementById('showAxes');
      const saveBtn = document.getElementById('saveBtn');
      const batchBtn = document.getElementById('batchBtn');
      const surfBtn = document.getElementById('surfBtn');
      const clearBtn = document.getElementById('clearBtn');
      const helpBtn = document.getElementById('helpBtn');
      // Side panel controls
      const panelBtn = document.getElementById('panelBtn');
      const sidePanel = document.getElementById('sidePanel');
      const sideClose = document.getElementById('sideClose');
      const helpOverlay = document.getElementById('helpOverlay');
      const helpClose = document.getElementById('helpClose');
      const coordsContent = document.getElementById('coordsContent');
      const copyXYZBtn = document.getElementById('copyXYZ');
      const downloadXYZBtn = document.getElementById('downloadXYZ');
      // View controls
      const shiftX = document.getElementById('shiftX');
      const shiftY = document.getElementById('shiftY');
      const shiftZ = document.getElementById('shiftZ');
      const camX = document.getElementById('camX');
      const camY = document.getElementById('camY');
      const camZ = document.getElementById('camZ');
      const tgtX = document.getElementById('tgtX');
      const tgtY = document.getElementById('tgtY');
      const tgtZ = document.getElementById('tgtZ');
      const autoRot = document.getElementById('autoRot');
      const rotSpeed = document.getElementById('rotSpeed');
      const damp = document.getElementById('damp');
      const autoRotSpeed = document.getElementById('autoRotSpeed');
      const viewReset = document.getElementById('viewReset');
      const styleSelect = document.getElementById('styleSelect');
      const schemeSelect = document.getElementById('schemeSelect');
      const renderModeSel = document.getElementById('renderMode');
      const cloudTypeSel = document.getElementById('cloudType');
      const cloudStrideEl = document.getElementById('cloudStride');
      const cloudAlphaEl = document.getElementById('cloudAlpha');

      openBtn.onclick = () => fileInput.click();
      // Toggle surface rendering button
      const updateSurfBtn = () => { surfBtn.textContent = showSurfaces ? 'Hide Surfaces' : 'Show Surfaces'; };
      updateSurfBtn();
      surfBtn.onclick = () => { showSurfaces = !showSurfaces; updateSurfBtn(); rebuildScene({ preserveView: true }); };
      const toggleSide = () => { sidePanel.classList.toggle('open'); sidePanel.setAttribute('aria-hidden', sidePanel.classList.contains('open') ? 'false' : 'true'); };
      const closeSide = () => { if (sidePanel.classList.contains('open')) { sidePanel.classList.remove('open'); sidePanel.setAttribute('aria-hidden', 'true'); } };
      panelBtn.onclick = toggleSide;
      sideClose.onclick = toggleSide;
      // Help modal logic
      function openHelp() { helpOverlay.style.display = 'flex'; helpOverlay.setAttribute('aria-hidden', 'false'); }
      function closeHelp() { helpOverlay.style.display = 'none'; helpOverlay.setAttribute('aria-hidden', 'true'); }
      if (helpBtn) helpBtn.onclick = openHelp;
      if (helpClose) helpClose.onclick = closeHelp;
      if (helpOverlay) helpOverlay.addEventListener('click', (e) => { if (e.target === helpOverlay) closeHelp(); });

      function refreshViewUI() {
        const notEditing = (el) => document.activeElement !== el;
        if (notEditing(shiftX)) shiftX.value = contentGroup.position.x.toFixed(3);
        if (notEditing(shiftY)) shiftY.value = contentGroup.position.y.toFixed(3);
        if (notEditing(shiftZ)) shiftZ.value = contentGroup.position.z.toFixed(3);
        if (notEditing(camX)) camX.value = camera.position.x.toFixed(3);
        if (notEditing(camY)) camY.value = camera.position.y.toFixed(3);
        if (notEditing(camZ)) camZ.value = camera.position.z.toFixed(3);
        if (notEditing(tgtX)) tgtX.value = controls.target.x.toFixed(3);
        if (notEditing(tgtY)) tgtY.value = controls.target.y.toFixed(3);
        if (notEditing(tgtZ)) tgtZ.value = controls.target.z.toFixed(3);
        autoRot.checked = controls.autoRotate === true;
        if (notEditing(rotSpeed)) rotSpeed.value = (controls.rotateSpeed ?? 1.0).toFixed(2);
        if (notEditing(damp)) damp.value = (controls.dampingFactor ?? 0.05).toFixed(2);
        if (notEditing(autoRotSpeed)) autoRotSpeed.value = (controls.autoRotateSpeed ?? 2.0).toFixed(2);
      }

      // Initialize view UI
      refreshViewUI();
      controls.addEventListener('change', refreshViewUI);

      // Reset view to the initial camera/target/shift
      viewReset.onclick = () => {
        if (defaultView) {
          contentGroup.position.copy(defaultView.contentPos);
          camera.copy(defaultView.cam);
          controls.target.copy(defaultView.target);
          controls.update();
          refreshViewUI();
        } else {
          fitCameraToScene();
          refreshViewUI();
        }
      };

      // Surface style selector
      if (styleSelect) {
        styleSelect.value = surfaceStyle;
        styleSelect.onchange = () => { surfaceStyle = styleSelect.value; rebuildScene({ preserveView: true }); };
      }

      // Default color schemes for +/- surfaces
      if (schemeSelect) {
        const schemes = {
          emory: { pos: '#f2a900', neg: '#0033a0' },
          national: { pos: '#e60000', neg: '#0033a0' },
          bright: { pos: '#ffcc00', neg: '#00bfff' },
          electron: { pos: '#ff00bf', neg: '#2eb82e' },
          classic: { pos: '#1f77b4', neg: '#d62728' },
        };
        schemeSelect.onchange = () => {
          const v = schemeSelect.value;
          const s = schemes[v];
          if (s) {
            posColor.value = s.pos;
            negColor.value = s.neg;
            updateOpacityAndColors();
          }
        };
      }

      // Render mode / cloud params
      let renderMode = (renderModeSel && renderModeSel.value) || 'surface';
      let cloudType = (cloudTypeSel && cloudTypeSel.value) || 'cubes';
      function updateRenderModeUI() {
        const isCloud = renderMode === 'cloud';
        const rowStyle = document.getElementById('rowStyle');
        const rowCloudType = document.getElementById('rowCloudType');
        const rowCloudParams = document.getElementById('rowCloudParams');
        if (rowStyle) rowStyle.style.display = isCloud ? 'none' : '';
        if (rowCloudType) rowCloudType.style.display = isCloud ? '' : 'none';
        if (rowCloudParams) rowCloudParams.style.display = isCloud ? '' : 'none';
      }
      function readCloudOpts() {
        const iso = Math.abs(parseFloat((isoInput && isoInput.value) || '0')) || 0;
        return {
          type: cloudType,
          stride: Math.max(1, parseInt((cloudStrideEl && cloudStrideEl.value) || '2', 10)),
          tLow: iso > 0 ? iso : 1e-6, // threshold tied to iso value
          alphaMax: Math.min(1, Math.max(0.05, parseFloat((cloudAlphaEl && cloudAlphaEl.value) || '0.05'))),
        };
      }
      if (renderModeSel) renderModeSel.onchange = () => { renderMode = renderModeSel.value; updateRenderModeUI(); rebuildScene({ preserveView: true }); };
      if (cloudTypeSel) cloudTypeSel.onchange = () => { cloudType = cloudTypeSel.value; rebuildScene({ preserveView: true }); };
      if (cloudStrideEl) cloudStrideEl.onchange = () => rebuildScene({ preserveView: true });
      if (cloudAlphaEl) cloudAlphaEl.onchange = () => rebuildScene({ preserveView: true });
      // Initialize UI visibility based on current mode
      updateRenderModeUI();

      // Axes gizmo state
      window.__showAxes__ = true;
      if (toggleAxes) toggleAxes.checked = !!window.__showAxes__;

      // Apply handlers
      const toNum = (v, def = 0) => { const n = parseFloat(v); return Number.isFinite(n) ? n : def; };
      for (const el of [shiftX, shiftY, shiftZ]) {
        el.oninput = () => {
          contentGroup.position.set(toNum(shiftX.value, 0), toNum(shiftY.value, 0), toNum(shiftZ.value, 0));
        };
      }
      for (const el of [camX, camY, camZ]) {
        el.oninput = () => {
          camera.position.set(toNum(camX.value, camera.position.x), toNum(camY.value, camera.position.y), toNum(camZ.value, camera.position.z));
          controls.update();
        };
      }
      for (const el of [tgtX, tgtY, tgtZ]) {
        el.oninput = () => {
          controls.target.set(toNum(tgtX.value, controls.target.x), toNum(tgtY.value, controls.target.y), toNum(tgtZ.value, controls.target.z));
          controls.update();
        };
      }
      autoRot.onchange = () => { controls.autoRotate = !!autoRot.checked; };
      rotSpeed.oninput = () => { const v = toNum(rotSpeed.value, 1.0); if (Number.isFinite(v)) controls.rotateSpeed = v; };
      damp.oninput = () => { const v = toNum(damp.value, 0.05); if (Number.isFinite(v)) controls.dampingFactor = v; };
      autoRotSpeed.oninput = () => { const v = toNum(autoRotSpeed.value, 2.0); if (Number.isFinite(v)) controls.autoRotateSpeed = v; };

      function updateSidePanel() {
        if (currentIndex < 0 || !volumes[currentIndex]) { coordsContent.innerHTML = '<em>No file loaded</em>'; return; }
        const v = volumes[currentIndex].vol;
        if (!v || !Array.isArray(v.atoms) || v.atoms.length === 0) { coordsContent.innerHTML = '<em>No atoms</em>'; return; }
        const rows = v.atoms.map((a, i) => {
          const z = a.Z | 0;
          const sym = (window.ATOM_Z_TO_DATA && window.ATOM_Z_TO_DATA[z] && window.ATOM_Z_TO_DATA[z].symbol) || String(z);
          const toAng = (v.units === 'angstrom');
          const x = toAng ? a.x : a.x * BOHR_TO_ANG;
          const y = toAng ? a.y : a.y * BOHR_TO_ANG;
          const zA = toAng ? a.z : a.z * BOHR_TO_ANG;
          return `<tr><td>${i + 1}</td><td>${sym}</td><td>${(a.Z | 0)}</td><td>${x.toFixed(3)}</td><td>${y.toFixed(3)}</td><td>${zA.toFixed(3)}</td></tr>`;
        }).join('');
        coordsContent.innerHTML = `
          <div style="margin-bottom:8px;color:var(--muted)">Active: ${volumes[currentIndex].name}</div>
          <table>
            <thead><tr><th>#</th><th>Sym</th><th>Z</th><th>x</th><th>y</th><th>z</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>`;
      }

      function toXYZString() {
        if (currentIndex < 0 || !volumes[currentIndex]) return '';
        const v = volumes[currentIndex].vol;
        if (!v || !Array.isArray(v.atoms)) return '';
        const atoms = v.atoms;
        const lines = [];
        lines.push(String(atoms.length));
        const comment = (v.title || volumes[currentIndex].name || '').toString();
        lines.push(comment);
        for (const a of atoms) {
          const z = a.Z | 0;
          const sym = (window.ATOM_Z_TO_DATA && window.ATOM_Z_TO_DATA[z] && window.ATOM_Z_TO_DATA[z].symbol) || String(z);
          const toAng = (v.units === 'angstrom');
          const x = toAng ? a.x : a.x * BOHR_TO_ANG;
          const y = toAng ? a.y : a.y * BOHR_TO_ANG;
          const zA = toAng ? a.z : a.z * BOHR_TO_ANG;
          lines.push(`${sym} ${x.toFixed(6)} ${y.toFixed(6)} ${zA.toFixed(6)}`);
        }
        return lines.join('\n');
      }

      copyXYZBtn.onclick = async () => {
        const txt = toXYZString();
        if (!txt) return;
        try {
          await navigator.clipboard.writeText(txt);
        } catch (e) {
          const ta = document.createElement('textarea');
          ta.value = txt; document.body.appendChild(ta); ta.select();
          try { document.execCommand('copy'); } catch { }
          document.body.removeChild(ta);
        }
      };

      downloadXYZBtn.onclick = () => {
        const txt = toXYZString();
        if (!txt) return;
        const blob = new Blob([txt], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const base = volumes[currentIndex] ? volumes[currentIndex].name.replace(/\.[^/.]+$/, '') : 'coords';
        a.download = `${base}.xyz`;
        a.href = url;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };

      async function handleFiles(fileList) {
        const arr = Array.from(fileList);
        // If demo is present and this is the first real load, clear it
        if (volumes.length === 1 && volumes[0].name === 'Demo Water') {
          console.log('[CUBE] Replacing demo with loaded file(s).');
          volumes = [];
          currentIndex = -1;
          clearSceneMeshes();
        }
        // Remove sample cube if present
        if (volumes.some(v => v.isSample)) {
          console.log('[CUBE] Removing sample.cube from list before adding user files.');
          volumes = volumes.filter(v => !v.isSample);
          currentIndex = -1;
          clearSceneMeshes();
        }
        const startIndex = volumes.length; // index of first newly added
        for (const f of arr) {
          const text = await f.text();
          const lower = f.name.toLowerCase();
          const vol = (lower.endsWith('.xyz')) ? parseXYZ(text) : parseCube(text);
          volumes.push({ name: f.name, vol });
          // adopt hinted iso if the user hasn’t interacted yet
          if (vol.isoHint != null && (isoInput.value === '' || currentIndex === -1)) {
            isoInput.value = String(vol.isoHint);
          }
          // Debug: print parsed volume info
          if (vol.data && vol.data.length) {
            try {
              const stats = arrayMinMax(vol.data);
              console.log('[CUBE] Loaded', f.name, { title: vol.title, nxyz: vol.nxyz, origin: vol.origin, axes: vol.axes, natoms: vol.natoms, isoHint: vol.isoHint, min: stats.min, max: stats.max });
            } catch (e) {
              console.warn('[CUBE] Stats failed for', f.name, e);
            }
          } else {
            console.log('[XYZ] Loaded', f.name, { natoms: vol.natoms });
          }
        }
        refreshFileSelect();
        if (volumes.length > 0) {
          // Select the first of the newly added files
          currentIndex = startIndex;
          if (fileSelect && fileSelect.options.length > currentIndex) {
            fileSelect.value = String(currentIndex);
          }
          rebuildScene();
          updateSidePanel();
        }
      }

      fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
      const drop = document.getElementById('drop');
      drop.addEventListener('dragover', e => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
      drop.addEventListener('drop', e => { e.preventDefault(); if (e.dataTransfer.files) handleFiles(e.dataTransfer.files); });
      // Close side panel when clicking on the scene (not during drags)
      let downPos = null;
      drop.addEventListener('pointerdown', (e) => {
        if (e.button === 0) downPos = { x: e.clientX, y: e.clientY };
        else downPos = null;
      });
      drop.addEventListener('pointerup', (e) => {
        if (!sidePanel.classList.contains('open')) { downPos = null; return; }
        if (!downPos) return;
        const dx = e.clientX - downPos.x, dy = e.clientY - downPos.y;
        const moved = Math.hypot(dx, dy) > 4; // threshold to distinguish drag
        downPos = null;
        if (!moved) closeSide();
      });

      // Clear cubes and show sample again
      clearBtn.onclick = async () => {
        volumes = [];
        currentIndex = -1;
        refreshFileSelect();
        clearSceneMeshes();
        const ok = await loadSampleCube();
        if (!ok) loadDemo();
      };

      function refreshFileSelect() {
        fileSelect.innerHTML = "";
        volumes.forEach((v, i) => {
          const opt = document.createElement('option');
          opt.value = i; opt.textContent = v.name;
          fileSelect.appendChild(opt);
        });
        if (currentIndex >= 0) fileSelect.value = currentIndex;
      }

      fileSelect.onchange = () => {
        currentIndex = parseInt(fileSelect.value, 10);
        // Preserve camera view (position, orientation, zoom) when switching files
        rebuildScene({ preserveView: true });
        updateSidePanel();
      };

      // (subsample controls removed)

      isoInput.onchange = () => rebuildScene({ preserveView: true });
      opInput.oninput = updateOpacityAndColors;
      posColor.oninput = () => { if (typeof schemeSelect !== 'undefined' && schemeSelect) schemeSelect.value = 'custom'; updateOpacityAndColors(); };
      negColor.oninput = () => { if (typeof schemeSelect !== 'undefined' && schemeSelect) schemeSelect.value = 'custom'; updateOpacityAndColors(); };
      bgColor.oninput = () => {
        // Update scene background to selected color
        try { scene.background = new THREE.Color(bgColor.value); } catch { }
      };
      toggleAtoms.onchange = () => rebuildScene({ preserveView: true });
      toggleBonds.onchange = () => rebuildScene({ preserveView: true });
      elementColors.onchange = () => rebuildScene({ preserveView: true });
      toggleBox.onchange = () => rebuildScene({ preserveView: true });
      if (toggleAxes) toggleAxes.onchange = () => { window.__showAxes__ = !!toggleAxes.checked; };

      function rebuildScene(options = {}) {
        const preserveView = !!options.preserveView;
        // Save current camera + controls target if preserving view
        const savedCam = preserveView ? camera.clone() : null;
        const savedTarget = preserveView ? controls.target.clone() : null;
        if (currentIndex < 0) return;
        clearSceneMeshes();
        const vol = volumes[currentIndex].vol;

        // Compute robust min/max
        const { min, max } = arrayMinMax(vol.data || []);

        // Auto-iso fallback: if requested iso shows nothing, lower it to ~95th percentile of |field|
        let iso = parseFloat(isoInput.value || "0.02");
        if (!(max >= iso || min <= -iso)) {
          // compute ~95th percentile on a sampled subset for speed
          const sampleStep = Math.max(1, Math.floor(vol.data.length / 50000));
          const absVals = [];
          for (let i = 0; i < vol.data.length; i += sampleStep) absVals.push(Math.abs(vol.data[i]));
          absVals.sort((a, b) => a - b);
          const p95 = absVals[Math.floor(0.95 * (absVals.length - 1))] || 0.0;
          iso = p95 || Math.max(Math.abs(min), Math.abs(max)) * 0.5;
          console.warn('[CUBE] Requested iso produced no surface. Falling back to', iso.toFixed(6));
        }

        const opacity = parseFloat(opInput.value || "1.00");
        const posMat = createIsoMaterial('pos', opacity);
        const negMat = createIsoMaterial('neg', opacity);

        const hasGrid = Array.isArray(vol.nxyz) && (vol.nxyz[0] > 0 && vol.nxyz[1] > 0 && vol.nxyz[2] > 0);
        if (renderMode === 'surface' && showSurfaces && hasGrid) {
          // Positive iso (+iso value, + color)
          if (max >= iso) {
            const geomP = makeIsosurface(vol, iso);
            const meshP = new THREE.Mesh(geomP, posMat);
            meshP.userData.sign = 'pos';
            contentGroup.add(meshP); meshes.push(meshP);
            // Debug: triangle count
            if (geomP.index) console.log('[ISO+] triangles', (geomP.index.count / 3) | 0);
          }
          // Negative iso (−iso value, − color)
          if (min <= -iso) {
            const geomN = makeIsosurface(vol, -iso);
            const meshN = new THREE.Mesh(geomN, negMat);
            meshN.userData.sign = 'neg';
            contentGroup.add(meshN); meshes.push(meshN);
            if (geomN.index) console.log('[ISO-] triangles', (geomN.index.count / 3) | 0);
          }
        } else if (renderMode === 'cloud' && showSurfaces && hasGrid) {
          const opts = readCloudOpts();
          cloudGroup = (opts.type === 'points') ? buildCloudPoints(vol, opts) : buildCloudCubes(vol, opts);
          contentGroup.add(cloudGroup);
        }

        // Atoms
        if (toggleAtoms.checked) {
          atomGroup = buildAtoms(volumes[currentIndex].vol);
          contentGroup.add(atomGroup);
        }
        // Bonds
        if (toggleBonds.checked) {
          bondGroup = buildBonds(volumes[currentIndex].vol);
          contentGroup.add(bondGroup);
        }

        // Box
        if (toggleBox.checked && hasGrid) {
          boxHelper = buildBox(vol);
          contentGroup.add(boxHelper);
          console.log('[CUBE] Box helper added');
        }

        if (preserveView && savedCam && savedTarget) {
          camera.copy(savedCam);
          controls.target.copy(savedTarget);
          controls.update();
        } else {
          fitCameraToScene();
          if (!defaultView) {
            defaultView = {
              cam: camera.clone(),
              target: controls.target.clone(),
              contentPos: contentGroup.position.clone(),
            };
          }
        }
        console.log('[CUBE] Rebuilt scene. iso=', iso, 'opacity=', opacity, 'min/max=', min, max);
        updateSidePanel();
      }

      function updateOpacityAndColors() {
        const op = parseFloat(opInput.value || "1.00");
        for (const m of meshes) {
          if (!m || !m.material) continue;
          const sign = m.userData && m.userData.sign;
          const colStr = sign === 'neg' ? negColor.value : posColor.value;
          const col = new THREE.Color(colStr);
          const mat = m.material;
          // Adapt behavior to glossy physical materials
          if (mat.isMeshPhysicalMaterial) {
            if (surfaceStyle === 'glass' && 'transmission' in mat) {
              // For glass: drive transmission with slider, keep alpha at 1
              col.multiplyScalar(2);
              mat.transmission = Math.max(0, Math.min(1, op));
              mat.color.copy(col);
            } else {
              // Emissive physical (default): use opacity, keep emissiveIntensity intact
              mat.opacity = op;
              mat.transparent = true;
              mat.color.copy(col);
              if (mat.emissive) mat.emissive.copy(col);
            }
          } else {
            // Fallback materials (standard/toon)
            mat.opacity = op;
            mat.transparent = true;
            mat.color.copy(col);
          }
          mat.needsUpdate = true;
        }
        // Update cloud colors as well
        if (cloudGroup && cloudGroup.children && cloudGroup.children.length) {
          for (const obj of cloudGroup.children) {
            const sign = obj.userData && obj.userData.sign;
            const colStr = sign === 'neg' ? negColor.value : posColor.value;
            if (!colStr) continue;
            if (obj.material) {
              const mat = obj.material;
              if (mat.isShaderMaterial && mat.uniforms && mat.uniforms.uColor) {
                mat.uniforms.uColor.value.set(colStr);
                mat.needsUpdate = true;
              } else if (mat.color) {
                mat.color.set(colStr);
                mat.needsUpdate = true;
              }
            }
          }
        }
      }

      saveBtn.onclick = () => {
        const link = document.createElement('a');
        const name = currentIndex >= 0 ? volumes[currentIndex].name.replace(/\.[^/.]+$/, '') : 'render';
        link.download = `${name}_iso${parseFloat(isoInput.value || "0.02").toFixed(4)}.png`;
        link.href = renderer.domElement.toDataURL('image/png');
        link.click();
      };

      batchBtn.onclick = async () => {
        if (volumes.length === 0) return;
        const keepCamera = camera.clone(); const keepTarget = controls.target.clone();

        for (let i = 0; i < volumes.length; i++) {
          currentIndex = i;
          fileSelect.value = i;
          rebuildScene();
          await new Promise(r => requestAnimationFrame(() => r()));
          const link = document.createElement('a');
          const name = volumes[i].name.replace(/\.[^/.]+$/, '');
          link.download = `${name}_iso${parseFloat(isoInput.value || "0.02").toFixed(4)}.png`;
          link.href = renderer.domElement.toDataURL('image/png');
          link.click();
          await new Promise(r => setTimeout(r, 120));
        }
        camera.copy(keepCamera); controls.target.copy(keepTarget); controls.update();
      };

      // Helpers to load the sample cube or demo
      async function loadSampleCube() {
        try {
          const resp = await fetch('./sample.cube', { cache: 'no-store' });
          if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
          const text = await resp.text();
          const vol = parseCube(text);
          volumes = [];
          currentIndex = -1;
          clearSceneMeshes();
          volumes.push({ name: 'sample.cube', vol, isSample: true });
          if (vol.isoHint != null && (isoInput.value === '' || currentIndex === -1)) {
            isoInput.value = String(vol.isoHint);
          }
          try {
            const stats = arrayMinMax(vol.data);
            console.log('[CUBE] Loaded sample.cube', { title: vol.title, nxyz: vol.nxyz, origin: vol.origin, axes: vol.axes, natoms: vol.natoms, isoHint: vol.isoHint, min: stats.min, max: stats.max });
          } catch (e) {
            console.warn('[CUBE] Stats failed for sample.cube', e);
          }
          currentIndex = 0;
          refreshFileSelect();
          rebuildScene();
          updateSidePanel();
          const hint = document.getElementById('hint');
          if (hint) hint.textContent = 'Loaded sample.cube • Orbit: mouse drag • Zoom: wheel • Pan: right-drag';
          return true;
        } catch (err) {
          console.warn('[CUBE] Could not auto-load sample.cube:', err);
          return false;
        }
      }

      function loadDemo() {
        const ANG_TO_BOHR = 1.0 / BOHR_TO_ANG;
        const r = 0.9572; // O–H bond length
        const theta = 104.5 * Math.PI / 180; // H–O–H angle
        const hx = r * Math.sin(theta / 2);
        const hz = r * Math.cos(theta / 2);
        const atoms = [
          { Z: (ATOM_SYMBOL_TO_Z.O || 8), q: 0, x: 0, y: 0, z: 0 },
          { Z: (ATOM_SYMBOL_TO_Z.H || 1), q: 0, x: hx * ANG_TO_BOHR, y: 0, z: hz * ANG_TO_BOHR },
          { Z: (ATOM_SYMBOL_TO_Z.H || 1), q: 0, x: -hx * ANG_TO_BOHR, y: 0, z: hz * ANG_TO_BOHR },
        ];
        const nx = 20, ny = 20, nz = 20;
        const step = 0.6; // Bohr per voxel along each axis
        const axes = [[step, 0, 0], [0, step, 0], [0, 0, step]];
        const origin = [-(nx * step) / 2, -(ny * step) / 2, -(nz * step) / 2]; // Bohr
        const data = new Float32Array(nx * ny * nz);
        const idx = (i, j, k) => (i * ny + j) * nz + k;
        const vol = { title: 'Demo Water', comment: '', natoms: 3, origin, nxyz: [nx, ny, nz], axes, atoms, data, idx, isoHint: null };
        volumes.push({ name: 'Demo Water', vol });
        currentIndex = 0;
        refreshFileSelect();
        rebuildScene();
        updateSidePanel();
      }

      // Startup: show sample cube, fallback to demo
      (async function initLoad() {
        if (volumes.length > 0) return;
        const ok = await loadSampleCube();
        if (!ok) loadDemo();
      })();

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        // Ignore shortcuts while typing in inputs
        const tag = (document.activeElement && document.activeElement.tagName) || '';
        const editing = tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
        if (e.key === 's' && !editing) saveBtn.click();
        if (e.key === 'b' && !editing) batchBtn.click();
        if ((e.key === 'i' || e.key === 'I') && !editing) { showSurfaces = !showSurfaces; if (typeof updateSurfBtn === 'function') updateSurfBtn(); rebuildScene({ preserveView: true }); }
        if ((e.key === 'x' || e.key === 'X') && !editing) {
          window.__showAxes__ = !window.__showAxes__;
          if (toggleAxes) toggleAxes.checked = !!window.__showAxes__;
        }
        if (!editing && (e.key === 'h' || e.key === 'H' || e.key === '?')) { if (helpOverlay && helpOverlay.style.display !== 'flex') openHelp(); else closeHelp(); }
        if (e.key === 'Escape') { closeSide(); if (helpOverlay) closeHelp(); }

        // Arrow keys: switch files (preserve camera)
        if (!editing && volumes.length > 0 && (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowUp')) {
          let delta = (e.key === 'ArrowRight' || e.key === 'ArrowDown') ? 1 : -1;
          const n = volumes.length;
          if (n > 0) {
            currentIndex = ((currentIndex + delta) % n + n) % n; // wrap safely
            if (fileSelect) fileSelect.value = String(currentIndex);
            rebuildScene({ preserveView: true });
            updateSidePanel();
            e.preventDefault();
          }
        }
      });

    })();
  </script>
</body>

</html>
