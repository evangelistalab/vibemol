<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VibeMol — CUBE Isosurface Viewer</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121822;
      --text: #e8eef6;
      --muted: #9ab;
      --accent: #4aa3ff;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font: 14px/1.3 system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    #toolbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--panel);
      border-bottom: 1px solid #223;
      padding: 8px 10px;
      display: flex;
      gap: 12px;
      align-items: center;
      z-index: 10;
      flex-wrap: wrap;
    }

    #toolbar label {
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--muted);
    }

    #toolbar input[type="number"] {
      width: 6.5em;
    }

    #toolbar input[type="range"] {
      width: 140px;
    }

    #toolbar input[type="color"] {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
    }

    #toolbar button {
      background: var(--accent);
      color: #003;
      border: none;
      padding: 6px 10px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
    }

    #toolbar button.secondary {
      background: #2a3344;
      color: #dfe7f3;
    }

    #toolbar .spacer {
      flex: 1;
    }

    #drop {
      position: fixed;
      top: 56px;
      left: 0;
      right: 0;
      bottom: 0;
    }

    /* Side panel for dynamic info */
    #sidePanel {
      position: fixed;
      top: 56px;
      right: 0;
      bottom: 0;
      width: 320px;
      background: var(--panel);
      border-left: 1px solid #223;
      box-shadow: -6px 0 16px #0006;
      transform: translateX(100%);
      transition: transform 160ms ease-in-out;
      z-index: 20;
      display: flex;
      flex-direction: column;
    }

    #sidePanel.open {
      transform: translateX(0);
    }

    #sideHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid #223;
      color: var(--text);
    }

    #sideHeader .title {
      font-weight: 600;
    }

    #sideClose {
      background: #2a3344;
      color: #dfe7f3;
      border: none;
      padding: 4px 8px;
      border-radius: 6px;
      cursor: pointer;
    }

    #coordsContent {
      padding: 10px 12px;
      overflow: auto;
      color: var(--text);
      font-size: 13px;
    }

    #viewControls {
      padding: 10px 12px;
      border-bottom: 1px solid #223;
      color: var(--text);
      background: #0f151f;
    }

    #viewControls .row {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      gap: 6px;
      margin-bottom: 8px;
      align-items: center;
    }

    #viewControls .row-vec {
      display: grid;
      grid-template-columns: 60px 10px 1fr 10px 1fr 10px 1fr;
      gap: 4px;
      margin-bottom: 8px;
      align-items: center;
    }

    #viewControls label {
      color: var(--muted);
      font-size: 12px;
    }

    #viewControls input[type="number"] {
      width: 100%;
      padding: 3px 6px;
      background: #1a2230;
      color: var(--text);
      border: 1px solid #223;
      border-radius: 4px;
    }

    #viewControls input[type="checkbox"] {
      vertical-align: middle;
    }

    #viewControls .axis {
      color: var(--muted);
      font-size: 12px;
      text-align: center;
    }

    #coordsContent table {
      width: 100%;
      border-collapse: collapse;
    }

    #coordsContent th,
    #coordsContent td {
      text-align: right;
      padding: 4px 6px;
      border-bottom: 1px solid #223;
    }

    #coordsContent th {
      text-align: left;
      color: var(--muted);
      font-weight: 600;
    }

    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #fileInput {
      display: none;
    }

    #hint {
      position: fixed;
      left: 12px;
      bottom: 10px;
      color: #9ab;
      background: #0f141d90;
      padding: 6px 8px;
      border-radius: 6px;
    }
  </style>
</head>

<body>
  <div id="toolbar">
    <label><strong>CUBE/XYZ files</strong>
      <input type="file" id="fileInput" accept=".cube,.cub,.xyz" multiple />
      <button id="openBtn" class="secondary">Open…</button>
    </label>
    <label>Active file
      <select id="fileSelect"></select>
    </label>
    <label>Iso
      <input type="number" id="iso" value="0.02" step="0.005" />
    </label>
    <label>Opacity
      <input type="range" id="opacity" min="0.05" max="1" step="0.01" value="1.00" />
    </label>
    <label>+ color <input type="color" id="posColor" value="#f2a900" /></label>
    <label>− color <input type="color" id="negColor" value="#0033a0" /></label>
    <label>BG <input type="color" id="bgColor" value="#ffffff" /></label>
    <label><input type="checkbox" id="showAtoms" checked /> atoms</label>
    <label><input type="checkbox" id="showBonds" checked /> bonds</label>
    <label><input type="checkbox" id="elementColors" checked /> elem colors</label>
    <label><input type="checkbox" id="showBox" /> box</label>
    <label><input type="checkbox" id="showAxes" checked /> axes</label>
    <div class="spacer"></div>
    <button id="saveBtn" title="Save the current view as a PNG image">Save PNG</button>
    <button id="batchBtn" class="secondary" title="Export all views as PNG images">Batch export</button>
    <button id="surfBtn" class="secondary" title="Toggle iso-surface rendering">Hide Surfaces</button>
    <button id="clearBtn" class="secondary" title="Clear all loaded cubes">Clear</button>
    <button id="editBtn" class="secondary" title="Enable molecule editing tools">Edit</button>
    <button id="panelBtn" class="secondary" title="View and coordinates">View/Coords</button>
    <button id="helpBtn" class="secondary" title="Help and shortcuts">Help</button>
  </div>

  <div id="drop">
    <canvas id="canvas"></canvas>
  </div>
  <div id="hint">Drag & drop .cube or .xyz files here • Orbit: mouse drag • Zoom: wheel • Pan: right-drag</div>

  <!-- Right side panel (toggle) -->
  <div id="sidePanel" aria-hidden="true">
    <div id="sideHeader">
      <div class="title">View</div>
      <div>
        <button id="viewReset" class="secondary" title="Reset the view to the initial state">Reset View</button>
        <button id="sideClose" title="Close">✕</button>
      </div>
    </div>

    <div id="viewControls">
      <div class="row-vec">
        <label>Shift</label>
        <span class="axis">X</span><input type="number" id="shiftX" step="0.1"
          title="Shift the molecule in the X-direction" />
        <span class="axis">Y</span><input type="number" id="shiftY" step="0.1"
          title="Shift the molecule in the Y-direction" />
        <span class="axis">Z</span><input type="number" id="shiftZ" step="0.1"
          title="Shift the molecule in the Z-direction" />
      </div>
      <div class="row-vec">
        <label>Cam</label>
        <span class="axis">X</span><input type="number" id="camX" step="0.1"
          title="Camera position in the X-direction" />
        <span class="axis">Y</span><input type="number" id="camY" step="0.1"
          title="Camera position in the Y-direction" />
        <span class="axis">Z</span><input type="number" id="camZ" step="0.1"
          title="Camera position in the Z-direction" />
      </div>
      <div class="row-vec">
        <label>Target</label>
        <span class="axis">X</span><input type="number" id="tgtX" step="0.1"
          title="Target position in the X-direction" />
        <span class="axis">Y</span><input type="number" id="tgtY" step="0.1"
          title="Target position in the Y-direction" />
        <span class="axis">Z</span><input type="number" id="tgtZ" step="0.1"
          title="Target position in the Z-direction" />
      </div>
      <div class="row">
        <label>Rotate speed</label><input type="number" id="rotSpeed" step="0.01"
          title="Speed at which the view rotates" />
        <label>Damping</label><input type="number" id="damp" step="0.01" title="Damping factor for the view rotation" />
      </div>
      <div class="row">
        <label style="width:100px"><input type="checkbox" id="autoRot" title="Toggle auto rotation of the camera" />
          Auto-rotate</label>
        <label>Speed</label><input type="number" id="autoRotSpeed" step="1" title="Speed of auto-rotation" />
      </div>
      <div class="row">
        <label style="width: 80px;">Color scheme</label>
        <select id="schemeSelect" title="Choose default +/- surface colors">
          <option value="emory" selected>Emory (gold/blue)</option>
          <option value="national">National (red/blue)</option>
          <option value="bright">Bright (yellow/cyan)</option>
          <option value="electron">Electron (magenta/green)</option>
          <option value="classic">Classic (blue/red)</option>
          <option value="custom">Custom (via color pickers)</option>
        </select>
        <span></span><span></span>
      </div>
      <div class="row">
        <label style="width: 80px;">Render mode</label>
        <select id="renderMode" title="Choose visualization mode">
          <option value="surface" selected>Surfaces</option>
          <option value="cloud">Cloud</option>
        </select>
        <span></span><span></span>
      </div>
      <div class="row">
        <label>FPS</label>
        <div id="fpsValue" style="font-variant-numeric: tabular-nums; color: var(--muted);">--</div>
        <span></span><span></span>
      </div>
      <div class="row" id="rowStyle">
        <label style="width: 80px;">Surface style</label>
        <select id="styleSelect" title="Choose iso-surface material style">
          <option value="emissive" selected>Emissive (physical)</option>
          <option value="glass">Glass (physical)</option>
        </select>
        <span></span><span></span>
      </div>
      <div class="row" id="rowCloudType">
        <label style="width: 80px;">Cloud type</label>
        <select id="cloudType" title="Cloud renderer">
          <option value="cubes" selected>Cubes</option>
          <option value="points">Points</option>
        </select>
        <span></span><span></span>
      </div>
      <div class="row" id="rowCloudParams">
        <label style="width: 80px;">Stride</label><input type="number" id="cloudStride" min="1" max="8" step="1"
          value="1" title="Sample every N voxels per axis" />
        <label>Alpha max</label><input type="number" id="cloudAlpha" min="0.025" max="1" step="0.025" value="0.1" />
      </div>
    </div>
    <div id="sideHeader">
      <div class="title">Coordinates (Å)</div>
      <div>
        <button id="copyXYZ" class="secondary" title="Copy XYZ">Copy</button>
        <button id="downloadXYZ" class="secondary" title="Download XYZ">Download</button>
      </div>
    </div>
    <div id="coordsContent">
      <!-- Filled dynamically -->
    </div>
  </div>

  <!-- Independent Edit panel (does not auto-close on scene clicks) -->
  <div id="editPanel" aria-hidden="true" style="display:none; position:fixed; top:56px; right:8px; width:340px; max-height:80vh; overflow:auto; background:var(--panel); color:var(--text); border:1px solid #223; border-radius:10px; box-shadow:0 10px 30px #000a; z-index:40;">
    <div style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid #223;">
      <div style="font-weight:700;">Edit</div>
      <div>
        <label style="margin-right:8px; color: var(--muted); font-size:12px;"><input type="checkbox" id="editEnable" /> Enable</label>
        <button id="editClose" class="secondary" title="Close">✕</button>
      </div>
    </div>
    <div style="padding:10px 12px; border-bottom: 1px solid #223;">
      <div style="display:grid; grid-template-columns: 1fr auto; gap:6px; align-items:center; margin-bottom:8px;">
        <label>Element</label>
        <div>
          <select id="elemSelect" title="Element for new atoms / changes">
            <option>H</option>
            <option>He</option>
            <option>C</option>
            <option>N</option>
            <option>O</option>
            <option>F</option>
            <option>Si</option>
            <option>P</option>
            <option>S</option>
            <option>Cl</option>
            <option>Br</option>
            <option>I</option>
          </select>
          <button id="elemOther" class="secondary" title="Pick from periodic table" style="margin-left:6px;">Other…</button>
        </div>
        <label>Bond order</label>
        <select id="bondOrder" title="Order for new bonds">
          <option value="auto" selected>Automatic</option>
          <option value="1">Single</option>
          <option value="2">Double</option>
          <option value="3">Triple</option>
        </select>
        <label>Adjust Hydrogens</label>
        <input type="checkbox" id="autoHydrogen" checked />
      </div>
      <div style="display:flex; justify-content:flex-end; gap:8px;">
        <button id="clearMolecule" class="secondary" title="Remove all atoms/bonds from this molecule">Clear molecule</button>
      </div>
    </div>
    <div style="padding:10px 12px; color:var(--muted); font-size:12px;">
      Tips: Click empty to add atom • Drag from atom to bond • Click atom to change element • Click bond to cycle order • Right‑click atom/bond to delete • Type element symbol (e.g., C, O, Si) or 1/2/3 for order
    </div>
  </div>

  <!-- Periodic table modal -->
  <div id="ptOverlay" aria-hidden="true" style="display:none; position:fixed; inset:0; background:#0008; z-index:60; align-items:center; justify-content:center;">
    <div role="dialog" aria-modal="true" style="background:var(--panel); color:var(--text); width:min(760px,92vw); max-height:80vh; overflow:auto; border:1px solid #223; border-radius:10px; box-shadow:0 10px 30px #000a;">
      <div style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid #223;">
        <div style="font-weight:700;">Pick Element</div>
        <button id="ptClose" class="secondary" title="Close">✕</button>
      </div>
      <div style="padding:12px 12px;">
        <input id="ptSearch" placeholder="Search symbol or name…" style="width:100%; padding:6px 8px; margin-bottom:8px; background:#1a2230; color:var(--text); border:1px solid #223; border-radius:6px;" />
        <div id="ptGrid" style="display:grid; grid-template-columns: repeat(12, minmax(40px, 1fr)); gap:6px;"></div>
      </div>
    </div>
  </div>

  <!-- Help / Shortcuts modal -->
  <div id="helpOverlay" aria-hidden="true"
    style="display:none; position:fixed; inset:0; background:#0008; z-index:50; align-items:center; justify-content:center;">
    <div id="helpModal" role="dialog" aria-modal="true"
      style="background:var(--panel); color:var(--text); width:min(680px,92vw); max-height:80vh; overflow:auto; border:1px solid #223; border-radius:10px; box-shadow:0 10px 30px #000a;">
      <div
        style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid #223;">
        <div style="font-weight:700;">Help & Shortcuts</div>
        <button id="helpClose" class="secondary" title="Close">✕</button>
      </div>
      <div style="padding:12px 14px; font-size:13px; line-height:1.45;">
        <p>Tips</p>
        <ul>
          <li>Orbit: mouse drag • Zoom: wheel • Pan: right-drag</li>
          <li>Use View/Coords to adjust camera, target, and scene shift.</li>
          <li>Atoms and Bonds can be toggled independently; bonds are color‑graded between atoms.</li>
          <li>The Cartesian coordinates are displayed as red (X), green (Y), and blue (Z) arrows.</li>
        </ul>
        <p>Shortcuts</p>
        <ul>
          <li><strong>S</strong> — Save PNG</li>
          <li><strong>B</strong> — Batch export all files</li>
          <li><strong>I</strong> — Toggle iso‑surfaces on/off</li>
          <li><strong>X</strong> — Toggle axis gizmo on/off</li>
          <li><strong>←/→</strong> or <strong>↑/↓</strong> — Previous / Next file (view preserved)</li>
          <li><strong>Esc</strong> — Close open menus/dialogs</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- three.js core and controls (local copies) -->
  <script src="./three.min.js"></script>
  <script src="./OrbitControls.global.js"></script>
  <!-- isosurface (global) -->
  <script src="isosurface.bundle.js"></script>
  <!-- atomic data (global) -->
  <script src="atomicData.js"></script>
  <!-- valence data (global, editable) -->
  <script src="valenceData.js"></script>

  <script>
    (function () {
      // --- Constants & helpers ---
      const BOHR_TO_ANG = 0.529177210903;
      const ANG_TO_BOHR = 1.0 / BOHR_TO_ANG;

      function arrayMinMax(a) {
        let min = Infinity, max = -Infinity;
        for (let i = 0; i < a.length; i++) {
          const v = a[i];
          if (v < min) min = v;
          if (v > max) max = v;
        }
        return { min, max };
      }

      function symToZ(sym) {
        return (window.ATOM_SYMBOL_TO_Z && window.ATOM_SYMBOL_TO_Z[String(sym || '').toUpperCase()]) || 0;
      }

      function zToData(z) {
        return (window.ATOM_Z_TO_DATA && window.ATOM_Z_TO_DATA[z]) || null;
      }

      function covalentRadius(z) {
        const d = zToData(z);
        return (d && typeof d.radius_covalent === 'number') ? d.radius_covalent : 0.7;
      }

      function defaultValence(z) {
        // Prefer external editable table if available
        if (window.VALENCE_Z && (z in window.VALENCE_Z)) return window.VALENCE_Z[z];
        // Fallback
        return 1;
      }

      function computeBondOrderByLength(z1, z2, distAng) {
        const sumR = covalentRadius(z1) + covalentRadius(z2);
        if (!isFinite(sumR) || sumR <= 0) return 1;
        if (distAng >= sumR) return 1;
        if (distAng >= 0.91 * sumR) return 2;
        return 3;
      }

      function worldToAtomUnits(vol, v3) {
        if (vol.units === 'angstrom') return [v3.x, v3.y, v3.z];
        return [v3.x * ANG_TO_BOHR, v3.y * ANG_TO_BOHR, v3.z * ANG_TO_BOHR];
      }

      function atomUnitsToAng(vol, a) {
        // a: {x,y,z}
        if (vol.units === 'angstrom') return new THREE.Vector3(a.x, a.y, a.z);
        return new THREE.Vector3(a.x * BOHR_TO_ANG, a.y * BOHR_TO_ANG, a.z * BOHR_TO_ANG);
      }

      function parseCube(text) {
        // Split lines, handle CRLF
        const lines = text.replace(/\r/g, '').split('\n');

        if (lines.length < 6) throw new Error("Not enough lines for a CUBE file.");

        const title = lines[0];
        const comment = lines[1];

        // Generic "(x,y)" capture anywhere on the 2nd line (your regex)
        let isoHint = null;
        {
          const m = comment.match(/\(([-+]?\d*\.?\d+(?:[eE][+-]?\d+)?)\s*,\s*([-+]?\d*\.?\d+(?:[eE][+-]?\d+)?)\)/);
          if (m) isoHint = parseFloat(m[1]); // take the first number as suggested level
        }

        // natoms / origin line
        const L3 = lines[2].trim().split(/\s+/);
        const natoms = parseInt(L3[0], 10);
        const origin = [parseFloat(L3[1]), parseFloat(L3[2]), parseFloat(L3[3])];

        // grid counts + per-voxel step vectors (Bohr)
        const sx = lines[3].trim().split(/\s+/).map(Number); // [numx, ax, ay, az]
        const sy = lines[4].trim().split(/\s+/).map(Number); // [numy, bx, by, bz]
        const sz = lines[5].trim().split(/\s+/).map(Number); // [numz, cx, cy, cz]
        const numx = Math.abs(sx[0]) | 0, numy = Math.abs(sy[0]) | 0, numz = Math.abs(sz[0]) | 0;
        const ax = sx.slice(1, 4); // per-voxel step along i
        const ay = sy.slice(1, 4); // per-voxel step along j
        const az = sz.slice(1, 4); // per-voxel step along k

        // atoms: Z, q, x, y, z  (positions in Bohr)
        const atoms = [];
        for (let i = 0; i < Math.abs(natoms); i++) {
          const p = lines[6 + i].trim().split(/\s+/).map(Number);
          atoms.push({ Z: p[0], q: p[1], x: p[2], y: p[3], z: p[4] });
        }

        // volumetric data (z fastest, then y, then x) — reshape (numx,numy,numz)
        const flat = lines.slice(6 + Math.abs(natoms)).join(' ').trim().split(/\s+/);
        const total = numx * numy * numz;
        if (flat.length < total) throw new Error(`Data size mismatch. Expected ${total}, got ${flat.length}`);
        const data = new Float32Array(total);
        for (let i = 0; i < total; i++) data[i] = parseFloat(flat[i]);

        // index helper matching your reshape: data[i,j,k]
        const idx = (i, j, k) => (i * numy + j) * numz + k;

        return {
          title, comment,
          natoms: Math.abs(natoms),
          origin,                        // Bohr
          nxyz: [numx, numy, numz],
          axes: [ax, ay, az],            // per-voxel step vectors in Bohr
          atoms, data, idx,
          units: 'bohr',                 // positions stored in Bohr
          isoHint                        // may be null if not present
        };
      }

      function parseXYZ(text) {
        const lines = text.replace(/\r/g, '').split('\n');
        let i = 0;
        // Optional first line atom count
        let natoms = 0;
        if (lines.length > 0) {
          const maybeN = parseInt((lines[0] || '').trim(), 10);
          if (!Number.isNaN(maybeN) && maybeN >= 0) {
            natoms = maybeN | 0; i = 2; // skip count + optional comment
          }
        }
        const atoms = [];
        for (; i < lines.length; i++) {
          const l = lines[i].trim();
          if (!l) continue;
          const parts = l.split(/\s+/);
          if (parts.length < 4) continue;
          const sym = parts[0];
          const Z = (window.ATOM_SYMBOL_TO_Z && window.ATOM_SYMBOL_TO_Z[sym.toUpperCase()]) || 0;
          const x = parseFloat(parts[1]);
          const y = parseFloat(parts[2]);
          const z = parseFloat(parts[3]);
          if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z)) {
            atoms.push({ Z, q: 0, x, y, z }); // XYZ is in Å already
          }
        }
        if (natoms === 0) natoms = atoms.length;
        const idx = (i, j, k) => 0;
        return { title: 'XYZ', comment: '', natoms, origin:[0,0,0], nxyz:[0,0,0], axes:[[1,0,0],[0,1,0],[0,0,1]], atoms, data:new Float32Array(0), idx, units: 'angstrom', kind: 'xyz' };
      }

      // (subsample removed)

      // Map a point in voxel grid coords (x,y,z in [0..nx-1], etc.) to world (Å)
      function voxelToWorld(vol, p) {
        const a = vol.axes[0].map(v => v * BOHR_TO_ANG);
        const b = vol.axes[1].map(v => v * BOHR_TO_ANG);
        const c = vol.axes[2].map(v => v * BOHR_TO_ANG);
        const o = vol.origin ? vol.origin.map(v => v * BOHR_TO_ANG) : [0, 0, 0];
        return [
          o[0] + p[0] * a[0] + p[1] * b[0] + p[2] * c[0],
          o[1] + p[0] * a[1] + p[1] * b[1] + p[2] * c[1],
          o[2] + p[0] * a[2] + p[1] * b[2] + p[2] * c[2],
        ];
      }

      function makeIsosurface(vol, level) {
        const [nx, ny, nz] = vol.nxyz;
        // MarchingCubes extracts the 0-level set of the potential.
        // To get an iso-surface at `level`, return field(x)-level.
        const sampler = (x, y, z) => {
          const i = Math.max(0, Math.min(nx - 1, Math.floor(x)));
          const j = Math.max(0, Math.min(ny - 1, Math.floor(y)));
          const k = Math.max(0, Math.min(nz - 1, Math.floor(z)));
          return vol.data[vol.idx(i, j, k)];
        };
        // Marching cubes → triangles (no explicit bounds => defaults to [[0,0,0],[nx,ny,nz]])
        const result = isosurface.marchingCubes([nx, ny, nz], (x, y, z) => sampler(x, y, z) - level);

        // Weld vertices across cube boundaries by deduplicating identical voxel-space positions.
        // Quantize voxel coords to a small grid to ensure stable keys.
        const voxPos = result.positions; // array of [x,y,z] in voxel units
        const key = (p) => `${Math.round(p[0] * 1e6)},${Math.round(p[1] * 1e6)},${Math.round(p[2] * 1e6)}`;
        const map = new Map();
        const unique = [];
        const oldToNew = new Uint32Array(voxPos.length);
        for (let i = 0; i < voxPos.length; i++) {
          const k = key(voxPos[i]);
          let idx = map.get(k);
          if (idx === undefined) {
            idx = unique.length;
            map.set(k, idx);
            unique.push(voxPos[i]);
          }
          oldToNew[i] = idx;
        }

        // Remap triangle indices through the welding map
        const cells = result.cells; // array of [a,b,c]
        const indices = new Uint32Array(cells.length * 3);
        for (let t = 0; t < cells.length; t++) {
          const c = cells[t];
          indices[3 * t + 0] = oldToNew[c[0]];
          indices[3 * t + 1] = oldToNew[c[1]];
          indices[3 * t + 2] = oldToNew[c[2]];
        }

        // Build world-space positions for the unique vertices
        const positions = new Float32Array(unique.length * 3);
        for (let i = 0; i < unique.length; i++) {
          const p = voxelToWorld(vol, unique[i]); // map voxel coords to Å
          positions[3 * i + 0] = p[0];
          positions[3 * i + 1] = p[1];
          positions[3 * i + 2] = p[2];
        }

        const geom = new THREE.BufferGeometry();
        geom.setIndex(new THREE.BufferAttribute(indices, 1));
        geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geom.computeVertexNormals();
        return geom;
      }

      // --- Three.js scene setup ---
      const canvas = document.getElementById('canvas');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });
      renderer.autoClear = false; // allow overlay rendering in same canvas
      const scene = new THREE.Scene();
      // Default to white background
      scene.background = new THREE.Color(0xffffff);
      const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 1e6);
      camera.position.set(60, 50, 60);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      // Default rotate speed
      controls.rotateSpeed = 1.5;

      // Lights
      const hemi = new THREE.HemisphereLight(0xffffff, 0x081018, 2.0);
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(1, 1, 1);
      const amb = new THREE.AmbientLight(0x999999, 0.65);
      scene.add(hemi, dir, amb);

      // Resizer
      function resize() {
        const panelH = 56; // toolbar height
        const w = window.innerWidth;
        const h = window.innerHeight - panelH;
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', resize);
      resize();

      // --- Corner axes (overlay) ---
      const axisScene = new THREE.Scene();
      // Use an orthographic camera so the gizmo stays centered without perspective shift
      const axisCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
      axisCamera.position.set(0, 0, 2);
      axisCamera.lookAt(0, 0, 0);
      const axisGizmo = new THREE.Group();
      // Simple lights so the gizmo shows shaded heads/shafts
      {
        const aHemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.9);
        const aDir = new THREE.DirectionalLight(0xffffff, 1.2); aDir.position.set(1, 1, 1);
        axisScene.add(aHemi, aDir);
      }
      function addShadedArrow(dir, color) {
        const g = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.35, metalness: 0.15 });
        // Shaft along +Y
        const shaftLen = 0.75, shaftRad = 0.05;
        const shaft = new THREE.Mesh(new THREE.CylinderGeometry(shaftRad, shaftRad, shaftLen, 16, 1), mat);
        shaft.position.y = shaftLen / 2;
        g.add(shaft);
        // Head (cone) along +Y
        const headLen = 0.30, headRad = 0.12;
        const head = new THREE.Mesh(new THREE.ConeGeometry(headRad, headLen, 20, 1), mat);
        head.position.y = shaftLen + headLen / 2;
        g.add(head);
        // Rotate to desired direction
        const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());
        g.setRotationFromQuaternion(q);
        axisGizmo.add(g);
      }
      addShadedArrow(new THREE.Vector3(1, 0, 0), 0xff4136); // X - red
      addShadedArrow(new THREE.Vector3(0, 1, 0), 0x2ecc40); // Y - green
      addShadedArrow(new THREE.Vector3(0, 0, 1), 0x0074d9); // Z - blue
      axisScene.add(axisGizmo);

      // State
      let volumes = []; // {name, vol}
      let currentIndex = -1;
      let meshes = []; // active meshes (pos/neg)
      let atomGroup = new THREE.Group();
      let bondGroup = new THREE.Group();
      let cloudGroup = new THREE.Group();
      let boxHelper = null;
      let showSurfaces = true; // toggle iso-surface visibility
      // Default view reference (captured on first non-preserved fit)
      let defaultView = null;
      // Current iso-surface material style
      let surfaceStyle = 'emissive';
      // Content group to allow whole-scene shifting
      const contentGroup = new THREE.Group();
      scene.add(contentGroup);
      contentGroup.add(atomGroup);
      contentGroup.add(bondGroup);
      contentGroup.add(cloudGroup);

      // --- Editing state & helpers ---
      let editEnabled = false;
      let selectedElement = 'C';
      let selectedZ = 6;
      let newBondOrderSetting = 'auto'; // 'auto' | '1' | '2' | '3'
      let autoHydrogens = true;

      const raycaster = new THREE.Raycaster();
      const ndc = new THREE.Vector2();
      function setNDCFromEvent(e) {
        const rect = renderer.domElement.getBoundingClientRect();
        ndc.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        ndc.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      }
      const tmpV = new THREE.Vector3();
      const tmpQ = new THREE.Quaternion();
      const tmpUp = new THREE.Vector3(0,1,0);

      // Drag-bond preview / hover highlight
      let dragFromAtom = null; // index for drag origin
      let dragGhost = null;    // Mesh (preview atom)
      let dragBond = null;     // Mesh (preview bond)
      let dragSnapTo = null;   // index to snap target
      let dragActive = false;  // becomes true after small movement threshold
      let createdStartAtomOnDown = false; // created a new atom on pointerdown
      let lastHoverMesh = null; // hovered atom mesh for highlight

      function clearHover() {
        if (lastHoverMesh && lastHoverMesh.material && lastHoverMesh.material.emissive) {
          const prev = lastHoverMesh.userData.prevEmissive;
          if (prev) lastHoverMesh.material.emissive.copy(prev);
        }
        lastHoverMesh = null;
      }

      function setHover(mesh) {
        if (!editEnabled) return;
        if (mesh === lastHoverMesh) return;
        if (lastHoverMesh && lastHoverMesh.material && lastHoverMesh.material.emissive) {
          const prev = lastHoverMesh.userData.prevEmissive;
          if (prev) lastHoverMesh.material.emissive.copy(prev);
        }
        lastHoverMesh = null;
        if (mesh && mesh.material && mesh.material.emissive) {
          mesh.userData.prevEmissive = mesh.material.emissive.clone();
          mesh.material.emissive.set(0xffff66);
          lastHoverMesh = mesh;
        }
      }

      function ensureBonds(vol) {
        if (Array.isArray(vol.bonds)) return;
        // Heuristic bonds with order=1
        const atoms = vol.atoms || [];
        const N = atoms.length;
        const bonds = [];
        for (let i = 0; i < N; i++) {
          const ai = atomUnitsToAng(vol, atoms[i]);
          for (let j = i + 1; j < N; j++) {
            const aj = atomUnitsToAng(vol, atoms[j]);
            const rij = ai.distanceTo(aj);
            const cutoff = 1.15 * (covalentRadius(atoms[i].Z|0) + covalentRadius(atoms[j].Z|0));
            if (rij > 0.4 && rij <= cutoff) bonds.push({ i, j, order: 1 });
          }
        }
        vol.bonds = bonds;
      }

      function addBond(vol, i, j, order) {
        if (i === j) return;
        ensureBonds(vol);
        // deduplicate
        for (const b of vol.bonds) {
          if ((b.i === i && b.j === j) || (b.i === j && b.j === i)) return;
        }
        vol.bonds.push({ i, j, order: Math.max(1, Math.min(3, order|0)) });
      }

      function cycleBondOrder(vol, hitBondIndex) {
        if (!vol.bonds || !vol.bonds[hitBondIndex]) return;
        const b = vol.bonds[hitBondIndex];
        b.order = (b.order % 3) + 1;
      }

      function removeBond(vol, hitBondIndex) {
        if (!vol.bonds) return null;
        if (hitBondIndex >= 0 && hitBondIndex < vol.bonds.length) {
          return vol.bonds.splice(hitBondIndex, 1)[0] || null;
        }
        return null;
      }

      function removeAtom(vol, idx) {
        const atoms = vol.atoms || [];
        if (idx < 0 || idx >= atoms.length) return;
        atoms.splice(idx, 1);
        if (Array.isArray(vol.bonds)) {
          const mapped = [];
          for (const b of vol.bonds) {
            if (b.i === idx || b.j === idx) continue;
            const ni = b.i > idx ? b.i - 1 : b.i;
            const nj = b.j > idx ? b.j - 1 : b.j;
            mapped.push({ i: ni, j: nj, order: b.order });
          }
          vol.bonds = mapped;
        }
      }

      function fibonacciSphereDirs(n) {
        const dirs = [];
        const g = (1 + Math.sqrt(5)) / 2; // golden ratio
        for (let i = 0; i < n; i++) {
          const t = i / Math.max(1, n);
          const z = 1 - 2 * t;
          const r = Math.sqrt(Math.max(0, 1 - z * z));
          const phi = 2 * Math.PI * i / g;
          dirs.push(new THREE.Vector3(r * Math.cos(phi), z, r * Math.sin(phi)));
        }
        return dirs;
      }

      function unit(v) { const l = v.length(); return l > 1e-9 ? v.multiplyScalar(1 / l) : v; }
      function projectOnPlane(v, n) { const t = n.clone().multiplyScalar(v.dot(n)); return v.clone().sub(t); }
      function angleBetweenOnAxis(u, v, axis) {
        const up = projectOnPlane(u.clone(), axis).normalize();
        const vp = projectOnPlane(v.clone(), axis).normalize();
        let ang = Math.acos(Math.min(1, Math.max(-1, up.dot(vp))));
        const cross = new THREE.Vector3().crossVectors(up, vp);
        if (cross.dot(axis) < 0) ang = -ang;
        return ang;
      }

      function sp3Slots() {
        const a = 1 / Math.sqrt(3);
        return [
          new THREE.Vector3( a,  a,  a),
          new THREE.Vector3( a, -a, -a),
          new THREE.Vector3(-a,  a, -a),
          new THREE.Vector3(-a, -a,  a),
        ];
      }
      function sp2Slots() {
        const c60 = 0.5, s60 = Math.sqrt(3) / 2;
        return [
          new THREE.Vector3(1, 0, 0),
          new THREE.Vector3(-c60,  s60, 0),
          new THREE.Vector3(-c60, -s60, 0),
        ];
      }
      function spSlots() { return [ new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0) ]; }

      function alignSlotsToNeighbors(slots, neighbors) {
        if (neighbors.length === 0) return slots.map(v => v.clone());
        const s0 = slots[0].clone();
        const n0 = unit(neighbors[0].clone());
        const q1 = new THREE.Quaternion().setFromUnitVectors(unit(s0.clone()), n0);
        const out = slots.map(v => v.clone().applyQuaternion(q1));
        if (neighbors.length >= 2) {
          const axis = n0.clone().normalize();
          const s1 = out[1].clone();
          const n1 = unit(neighbors[1].clone());
          const ang = angleBetweenOnAxis(s1, n1, axis);
          const q2 = new THREE.Quaternion().setFromAxisAngle(axis, ang);
          for (let i = 0; i < out.length; i++) out[i].applyQuaternion(q2);
        }
        return out;
      }

      function placeHydrogensGeometry(vol, idx, count) {
        if (count <= 0) return true;
        ensureBonds(vol);
        const atoms = vol.atoms;
        const center = atomUnitsToAng(vol, atoms[idx]);
        const rX = covalentRadius(atoms[idx].Z | 0) || 0.7;
        const rH = covalentRadius(1) || 0.31;
        const bondLen = Math.min(1.3, Math.max(0.7, rX + rH));
        const neighbors = [];
        for (const b of vol.bonds) {
          const other = (b.i === idx) ? b.j : (b.j === idx ? b.i : -1);
          if (other >= 0 && ((atoms[other].Z | 0) !== 1)) { // only heavy neighbors for alignment
            const v = atomUnitsToAng(vol, atoms[other]).sub(center).normalize();
            neighbors.push(v);
          }
        }
        const val = defaultValence((atoms[idx].Z | 0));
        let base;
        if (val >= 4) base = sp3Slots();
        else if (val === 3) base = sp2Slots();
        else if (val === 2) base = spSlots();
        else if (val === 1) base = [ new THREE.Vector3(1,0,0) ];
        else base = null;
        if (!base) return false;
        // Align to neighbors and mark occupied slots
        const aligned = alignSlotsToNeighbors(base, neighbors);
        const used = new Array(aligned.length).fill(false);
        for (const n of neighbors) {
          // Find nearest slot by angle
          let bi = -1, best = -Infinity;
          for (let i = 0; i < aligned.length; i++) {
            const d = aligned[i].dot(n);
            if (d > best) { best = d; bi = i; }
          }
          if (bi >= 0 && best > Math.cos(50 * Math.PI/180)) used[bi] = true; // mark if somewhat aligned
        }
        // Place on free slots
        let placed = 0;
        for (let i = 0; i < aligned.length && placed < count; i++) {
          if (used[i]) continue;
          const pos = center.clone().addScaledVector(aligned[i], bondLen);
          const [x, y, z] = worldToAtomUnits(vol, pos);
          atoms.push({ Z: 1, q: 0, x, y, z });
          const j = atoms.length - 1;
          addBond(vol, idx, j, 1);
          used[i] = true; placed++;
        }
        return placed === count;
      }

      function placeHydrogensMaxSpread(vol, idx, count) {
        if (count <= 0) return;
        ensureBonds(vol);
        const atoms = vol.atoms;
        const center = atomUnitsToAng(vol, atoms[idx]);
        // Determine target bond length (Å) ~ covalent radii sum
        const rX = covalentRadius(atoms[idx].Z | 0) || 0.7;
        const rH = covalentRadius(1) || 0.31;
        const bondLen = Math.min(1.3, Math.max(0.7, rX + rH));
        // Existing neighbor directions
        const neighbors = [];
        for (const b of vol.bonds) {
          const other = (b.i === idx) ? b.j : (b.j === idx ? b.i : -1);
          if (other >= 0) {
            const p = atomUnitsToAng(vol, atoms[other]);
            const d = p.clone().sub(center).normalize();
            neighbors.push(d);
          }
        }
        // Greedy pick candidates far from neighbors and prior picks
        const candidates = fibonacciSphereDirs(96);
        const chosen = [];
        function scoreDir(u) {
          let best = 1.0;
          for (const d of neighbors) { best = Math.min(best, 1 - Math.abs(THREE.MathUtils.clamp(u.dot(d), -1, 1))); }
          for (const d of chosen) { best = Math.min(best, 1 - Math.abs(THREE.MathUtils.clamp(u.dot(d), -1, 1))); }
          return best;
        }
        for (let k = 0; k < count; k++) {
          let bestU = candidates[0];
          let bestS = -Infinity;
          for (const u of candidates) {
            const s = scoreDir(u);
            if (s > bestS) { bestS = s; bestU = u; }
          }
          chosen.push(bestU.clone());
          // Place hydrogen
          const pos = center.clone().addScaledVector(bestU, bondLen);
          const [x, y, z] = worldToAtomUnits(vol, pos);
          atoms.push({ Z: 1, q: 0, x, y, z });
          const j = atoms.length - 1;
          addBond(vol, idx, j, 1);
        }
      }

      function addHydrogensIfNeeded(vol, idx) {
        if (!autoHydrogens) return;
        const atoms = vol.atoms || [];
        if (!atoms[idx]) return;
        const Zi = atoms[idx].Z | 0;
        if (Zi === 1) return; // skip H itself
        const val = defaultValence(Zi);
        if (val <= 0) return;
        ensureBonds(vol);
        let used = 0;
        for (const b of vol.bonds) {
          if (b.i === idx || b.j === idx) used += b.order || 1;
        }
        let need = Math.max(0, val - used);
        if (need <= 0) return;
        if (!placeHydrogensGeometry(vol, idx, need)) {
          placeHydrogensMaxSpread(vol, idx, need);
        }
      }

      function repositionHydrogens(vol, idx) {
        ensureBonds(vol);
        const atoms = vol.atoms || [];
        if (!atoms[idx]) return;
        const center = atomUnitsToAng(vol, atoms[idx]);
        const ZX = atoms[idx].Z | 0;
        if (ZX === 1) return; // not for hydrogen itself
        // Collect neighbors
        const hIdx = [];
        const heavyDirs = [];
        for (const b of vol.bonds) {
          if (!(b.i === idx || b.j === idx)) continue;
          const other = (b.i === idx) ? b.j : b.i;
          const Z = (atoms[other].Z | 0);
          const p = atomUnitsToAng(vol, atoms[other]);
          const d = p.clone().sub(center).normalize();
          if (Z === 1) hIdx.push(other); else heavyDirs.push(d);
        }
        if (hIdx.length === 0) return;
        // Compute target slots
        const val = defaultValence(ZX);
        let base;
        if (val >= 4) base = sp3Slots();
        else if (val === 3) base = sp2Slots();
        else if (val === 2) base = spSlots();
        else base = sp3Slots(); // fallback
        const aligned = alignSlotsToNeighbors(base, heavyDirs);
        // Mark slots occupied by heavy neighbors
        const used = new Array(aligned.length).fill(false);
        for (const n of heavyDirs) {
          let bi = -1, best = -Infinity;
          for (let i = 0; i < aligned.length; i++) {
            const d = aligned[i].dot(n);
            if (d > best) { best = d; bi = i; }
          }
          if (bi >= 0) used[bi] = true;
        }
        let targets = [];
        for (let i = 0; i < aligned.length; i++) if (!used[i]) targets.push(aligned[i].clone());
        // If not enough targets, extend via max-spread around heavyDirs
        if (targets.length < hIdx.length) {
          const need = hIdx.length - targets.length;
          const cand = fibonacciSphereDirs(96);
          function scoreDir(u) {
            let s = 1.0;
            for (const d of heavyDirs) s = Math.min(s, 1 - Math.abs(THREE.MathUtils.clamp(u.dot(d), -1, 1)));
            for (const d of targets) s = Math.min(s, 1 - Math.abs(THREE.MathUtils.clamp(u.dot(d), -1, 1)));
            return s;
          }
          const chosen = [];
          for (let k = 0; k < need; k++) {
            let bestU = cand[0], bestS = -Infinity;
            for (const u of cand) { const sc = scoreDir(u); if (sc > bestS) { bestS = sc; bestU = u; } }
            targets.push(bestU.clone());
            chosen.push(bestU);
          }
        } else if (targets.length > hIdx.length) {
          targets = targets.slice(0, hIdx.length);
        }
        // Assign hydrogens to targets to minimize movement
        const rX = covalentRadius(ZX) || 0.7;
        const rH = covalentRadius(1) || 0.31;
        const bondLen = Math.min(1.3, Math.max(0.7, rX + rH));
        const hDirs = hIdx.map(j => atomUnitsToAng(vol, atoms[j]).sub(center).normalize());
        const assigned = new Array(hIdx.length).fill(false);
        for (const t of targets) {
          let bestI = -1, bestDot = -Infinity;
          for (let i = 0; i < hDirs.length; i++) {
            if (assigned[i]) continue;
            const d = hDirs[i].dot(t);
            if (d > bestDot) { bestDot = d; bestI = i; }
          }
          if (bestI >= 0) {
            const j = hIdx[bestI];
            const pos = center.clone().addScaledVector(t, bondLen);
            const [x, y, z] = worldToAtomUnits(vol, pos);
            atoms[j].x = x; atoms[j].y = y; atoms[j].z = z;
            assigned[bestI] = true;
          }
        }
      }

      function trimHydrogensIfExcess(vol, idx) {
        if (!autoHydrogens) return;
        ensureBonds(vol);
        const atoms = vol.atoms || [];
        const Zi = (atoms[idx] && atoms[idx].Z) | 0;
        const val = defaultValence(Zi);
        if (val <= 0) return;
        // Compute current used valence
        const usedValence = () => {
          let u = 0;
          for (const b of vol.bonds) if (b.i === idx || b.j === idx) u += b.order || 1;
          return u;
        };
        // If over valence, remove bonded hydrogens first (one by one, re-scanning each time)
        while (usedValence() > val) {
          let removed = false;
          for (let bi = 0; bi < vol.bonds.length; bi++) {
            const b = vol.bonds[bi];
            if (!(b.i === idx || b.j === idx)) continue;
            const other = (b.i === idx) ? b.j : b.i;
            if ((atoms[other].Z | 0) === 1) {
              removeBond(vol, bi);
              removeAtom(vol, other);
              removed = true;
              break;
            }
          }
          if (!removed) break; // nothing left to remove safely
        }
      }

      function adjustHydrogens(vol, idx) {
        if (!autoHydrogens) return;
        trimHydrogensIfExcess(vol, idx);
        addHydrogensIfNeeded(vol, idx);
        repositionHydrogens(vol, idx);
      }

      function clearSceneMeshes() {
        for (const m of meshes) contentGroup.remove(m), m.geometry.dispose(), m.material.dispose();
        meshes = [];
        // Reset atom and bond groups
        contentGroup.remove(atomGroup); atomGroup.clear(); atomGroup = new THREE.Group();
        contentGroup.remove(bondGroup); bondGroup.clear(); bondGroup = new THREE.Group();
        contentGroup.remove(cloudGroup); cloudGroup.clear(); cloudGroup = new THREE.Group();
        if (boxHelper) { contentGroup.remove(boxHelper); boxHelper.geometry.dispose(); boxHelper.material.dispose(); boxHelper = null; }
      }

      function buildAtoms(vol) {
        const group = new THREE.Group();
        // Atoms (spheres)
        const sphere = new THREE.SphereGeometry(0.5, 20, 12);
        // Covalent radii from atomic data (Å)
        const covR = (z) => (ATOM_Z_TO_DATA && ATOM_Z_TO_DATA[z] && ATOM_Z_TO_DATA[z].radius_covalent) || 0.70;
        const atomPositions = [];
        const toAng = (vol.units === 'angstrom');
        for (const a of vol.atoms) {
          const r = covR(a.Z | 0);
          // Element-based color if enabled
          let atomColor = new THREE.Color(0xffffff);
          if (typeof elementColors !== 'undefined' && elementColors && elementColors.checked && ATOM_Z_TO_DATA) {
            const info = ATOM_Z_TO_DATA[a.Z | 0];
            if (info && Array.isArray(info.color)) {
              const [cr, cg, cb] = info.color;
              atomColor = new THREE.Color(cr / 255, cg / 255, cb / 255);
            }
          }
          const mat = new THREE.MeshStandardMaterial({ color: atomColor, roughness: 0.25, metalness: 0.25 });
          const mesh = new THREE.Mesh(sphere, mat);
          const px = toAng ? a.x : a.x * BOHR_TO_ANG;
          const py = toAng ? a.y : a.y * BOHR_TO_ANG;
          const pz = toAng ? a.z : a.z * BOHR_TO_ANG;
          const pos = new THREE.Vector3(px, py, pz);
          mesh.position.copy(pos);
          mesh.scale.setScalar(r * 1.2);
          mesh.userData = { type: 'atom', index: atomPositions.length };
          group.add(mesh);
          atomPositions.push({ pos, Z: a.Z | 0 });
        }
        return group;
      }

      function buildBonds(vol) {
        const group = new THREE.Group();
        ensureBonds(vol);
        const atomPositions = vol.atoms.map(a => atomUnitsToAng(vol, a));
        const bondMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.1, metalness: 0.1 });
        const up = new THREE.Vector3(0, 1, 0);
        const baseR = 0.12;
        for (let bi = 0; bi < vol.bonds.length; bi++) {
          const b = vol.bonds[bi];
          const aPos = atomPositions[b.i];
          const bPos = atomPositions[b.j];
          if (!aPos || !bPos) continue;
          const dir = new THREE.Vector3().subVectors(bPos, aPos);
          const len = dir.length();
          if (len < 0.1) continue;
          const mid = new THREE.Vector3().addVectors(aPos, bPos).multiplyScalar(0.5);
          const order = Math.max(1, Math.min(3, (b.order|0) || 1));
          const geom = new THREE.CylinderGeometry(baseR * (0.9 + 0.35*(order-1)), baseR * (0.9 + 0.35*(order-1)), len, 16, 1, false);
          const cyl = new THREE.Mesh(geom, bondMat);
          cyl.position.copy(mid);
          const q = new THREE.Quaternion().setFromUnitVectors(up, dir.normalize());
          cyl.setRotationFromQuaternion(q);
          cyl.userData = { type: 'bond', index: bi };
          group.add(cyl);
        }
        return group;
      }

      function buildBox(vol) {
        const [nx, ny, nz] = vol.nxyz;
        // Use cell-corner indexing: far corner at (nx,ny,nz) works visually, but try (nx-1,...) to stay within data
        const nx1 = Math.max(0, nx - 1), ny1 = Math.max(0, ny - 1), nz1 = Math.max(0, nz - 1);
        const corners = [
          [0, 0, 0], [nx1, 0, 0], [0, ny1, 0], [0, 0, nz1],
          [nx1, ny1, 0], [nx1, 0, nz1], [0, ny1, nz1], [nx1, ny1, nz1]
        ].map(p => new THREE.Vector3(...voxelToWorld(vol, p)));
        const geom = new THREE.BufferGeometry();
        const verts = new Float32Array(24 * 3);
        const edges = [
          [0, 1], [0, 2], [0, 3], [7, 6], [7, 5], [7, 4], [1, 4], [1, 5], [2, 4], [2, 6], [3, 5], [3, 6]
        ];
        edges.forEach((e, i) => {
          verts[6 * i + 0] = corners[e[0]].x; verts[6 * i + 1] = corners[e[0]].y; verts[6 * i + 2] = corners[e[0]].z;
          verts[6 * i + 3] = corners[e[1]].x; verts[6 * i + 4] = corners[e[1]].y; verts[6 * i + 5] = corners[e[1]].z;
        });
        geom.setAttribute('position', new THREE.BufferAttribute(verts, 3));
        const mat = new THREE.LineBasicMaterial({ color: 0xd3d3d3, linewidth: 1, depthTest: false, transparent: true, opacity: 0.9 });
        return new THREE.LineSegments(geom, mat);
      }

      // --- Surface material helpers ---
      function createIsoMaterial(sign, opacity) {
        const col = new THREE.Color(sign === 'neg' ? negColor.value : posColor.value);
        if (surfaceStyle === 'glass') {
          col.multiplyScalar(2);
          return new THREE.MeshPhysicalMaterial({
            color: col,
            transmission: 1.0,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 0.8,
            clearcoatRoughness: 0.025,
            reflectivity: 0.1,
            ior: 1.2,
            thickness: 1.0,
            side: THREE.DoubleSide,
          });
        }
        if (surfaceStyle === 'emissive') {
          return new THREE.MeshPhysicalMaterial({
            color: col,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            emissive: col.clone(),
            emissiveIntensity: 0.8,
            side: THREE.DoubleSide,
            transparent: true,
            opacity
          });
        }
        // Fallback standard
        return new THREE.MeshStandardMaterial({ color: col, roughness: 0.4, metalness: 0.05, side: THREE.DoubleSide, transparent: true, opacity });
      }

      // --- Cloud builders ---
      function voxelCenterToWorld(vol, i, j, k) {
        // position at cell center: (i+0.5, j+0.5, k+0.5)
        return voxelToWorld(vol, [i + 0.5, j + 0.5, k + 0.5]);
      }

      function estimateCellSize(vol) {
        // average step magnitude in Å
        const ax = vol.axes[0].map(v => v * BOHR_TO_ANG);
        const ay = vol.axes[1].map(v => v * BOHR_TO_ANG);
        const az = vol.axes[2].map(v => v * BOHR_TO_ANG);
        const len = v => Math.hypot(v[0], v[1], v[2]);
        return (len(ax) + len(ay) + len(az)) / 3;
      }

      function absPercentile(vol, p, stride) {
        const [nx, ny, nz] = vol.nxyz;
        const step = Math.max(1, stride | 0);
        const arr = [];
        for (let i = 0; i < nx; i += step) {
          for (let j = 0; j < ny; j += step) {
            for (let k = 0; k < nz; k += step) {
              const v = Math.abs(vol.data[vol.idx(i, j, k)]);
              arr.push(v);
            }
          }
        }
        if (arr.length === 0) return 0;
        arr.sort((a, b) => a - b);
        const idx = Math.min(arr.length - 1, Math.max(0, Math.floor(p * (arr.length - 1))));
        return arr[idx];
      }

      function buildCloudCubes(vol, opts) {
        const g = new THREE.Group();
        const [nx, ny, nz] = vol.nxyz;
        const stride = Math.max(1, opts.stride | 0);
        // Compute voxel edge lengths in Å and scale so adjacent samples touch.
        const ax = vol.axes[0].map(v => v * BOHR_TO_ANG);
        const ay = vol.axes[1].map(v => v * BOHR_TO_ANG);
        const az = vol.axes[2].map(v => v * BOHR_TO_ANG);
        const len = v => Math.hypot(v[0], v[1], v[2]);
        const scaleVec = new THREE.Vector3(len(ax) * stride, len(ay) * stride, len(az) * stride);
        // Determine high bound
        const hi = opts.hiMode === 'max' ? Math.max(...vol.data.map(v => Math.abs(v))) : absPercentile(vol, 0.99, Math.max(1, stride));
        const tLow = opts.tLow;
        const clamp01 = x => Math.max(0, Math.min(1, x));
        // Count instances per sign
        let nPos = 0, nNeg = 0;
        for (let i = 0; i < nx; i += stride) {
          for (let j = 0; j < ny; j += stride) {
            for (let k = 0; k < nz; k += stride) {
              const v = vol.data[vol.idx(i, j, k)];
              const av = Math.abs(v);
              if (av < tLow) continue;
              if (v >= 0) nPos++; else nNeg++;
            }
          }
        }
        const makeInst = (count, color) => {
          const geom = new THREE.BoxGeometry(1, 1, 1);
          const alpha = Math.min(1, opts.alphaMax * stride);
          const mat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(color),
            transparent: alpha < 1.0,
            opacity: alpha,
            depthWrite: alpha >= 1.0,
            depthTest: true,
            dithering: true,
            polygonOffset: true,
            polygonOffsetFactor: -0.5,
            polygonOffsetUnits: -1.0,
          });
          return new THREE.InstancedMesh(geom, mat, Math.max(1, count));
        };
        const instPos = makeInst(nPos, posColor.value); instPos.userData.sign = 'pos';
        const instNeg = makeInst(nNeg, negColor.value); instNeg.userData.sign = 'neg';
        let ip = 0, ineg = 0;
        const m4 = new THREE.Matrix4();
        const q = new THREE.Quaternion();
        const s = new THREE.Vector3();
        for (let i = 0; i < nx; i += stride) {
          for (let j = 0; j < ny; j += stride) {
            for (let k = 0; k < nz; k += stride) {
              const v = vol.data[vol.idx(i, j, k)];
              const av = Math.abs(v);
              if (av < tLow) continue;
              const pos = voxelCenterToWorld(vol, i, j, k);
              // Slightly shrink to mitigate coplanar z-fighting while still appearing contiguous
              m4.compose(new THREE.Vector3(pos[0], pos[1], pos[2]), q.identity(), s.copy(scaleVec).multiplyScalar(0.99));
              if (v >= 0) { instPos.setMatrixAt(ip++, m4); }
              else { instNeg.setMatrixAt(ineg++, m4); }
            }
          }
        }
        instPos.instanceMatrix.needsUpdate = true;
        instNeg.instanceMatrix.needsUpdate = true;
        g.add(instPos, instNeg);
        return g;
      }

      function buildCloudPoints(vol, opts) {
        const g = new THREE.Group();
        const [nx, ny, nz] = vol.nxyz;
        const stride = Math.max(1, opts.stride | 0);
        const tLow = opts.tLow;
        // Determine hi bound for strength mapping
        const hi = absPercentile(vol, 0.99, Math.max(1, stride));
        const clamp01 = x => Math.max(0, Math.min(1, x));
        // Collect positions and strength per sign
        const posPos = [], posNeg = [], strPos = [], strNeg = [];
        for (let i = 0; i < nx; i += stride) {
          for (let j = 0; j < ny; j += stride) {
            for (let k = 0; k < nz; k += stride) {
              const v = vol.data[vol.idx(i, j, k)];
              const av = Math.abs(v);
              if (av < tLow) continue;
              const s = clamp01((av - tLow) / Math.max(1e-12, (hi - tLow)));
              const p = voxelCenterToWorld(vol, i, j, k);
              if (v >= 0) { posPos.push(p[0], p[1], p[2]); strPos.push(s); }
              else { posNeg.push(p[0], p[1], p[2]); strNeg.push(s); }
            }
          }
        }
        // Shader material for round, shaded sprites
        const baseSize = estimateCellSize(vol) * 12.0; // uniform size, independent of stride/strength
        const makeSpriteMat = (colorHex) => new THREE.ShaderMaterial({
          uniforms: {
            uColor: { value: new THREE.Color(colorHex) },
            uAlpha: { value: Math.min(1.0, opts.alphaMax * stride) },
            uSize: { value: baseSize },
          },
          vertexShader: `
            uniform float uSize;
            attribute float aStrength;
            varying float vStrength;
            void main() {
              vStrength = aStrength;
              vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
              // approximate size attenuation (constant base size)
              float dist = -mvPosition.z;
              gl_PointSize = uSize * (300.0 / max(1.0, dist));
              gl_Position = projectionMatrix * mvPosition;
            }
          `,
          fragmentShader: `
            uniform vec3 uColor;
            uniform float uAlpha;
            varying float vStrength;
            void main() {
              vec2 uv = gl_PointCoord - vec2(0.5);
              float d = length(uv);
              if (d > 0.5) discard; // round sprite
              float fall = smoothstep(0.5, 0.0, d);
              float a = uAlpha * vStrength * fall;
              gl_FragColor = vec4(uColor, a);
            }
          `,
          transparent: true,
          depthWrite: false,
          depthTest: false,
          blending: THREE.NormalBlending,
        });
        const makePoints = (posArr, strArr, color, sign) => {
          const geo = new THREE.BufferGeometry();
          geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(posArr), 3));
          geo.setAttribute('aStrength', new THREE.BufferAttribute(new Float32Array(strArr), 1));
          const mat = makeSpriteMat(color);
          const pts = new THREE.Points(geo, mat);
          pts.userData.sign = sign;
          return pts;
        };
        if (posPos.length) g.add(makePoints(posPos, strPos, posColor.value, 'pos'));
        if (posNeg.length) g.add(makePoints(posNeg, strNeg, negColor.value, 'neg'));
        return g;
      }

      function fitCameraToScene() {
        const box = new THREE.Box3();
        let hasSomething = false;
        for (const m of meshes) { box.expandByObject(m); hasSomething = true; }
        if (atomGroup.children.length) { box.expandByObject(atomGroup); hasSomething = true; }
        if (bondGroup.children.length) { box.expandByObject(bondGroup); hasSomething = true; }
        if (boxHelper) { box.expandByObject(boxHelper); hasSomething = true; }
        if (!hasSomething || box.isEmpty()) return;

        const size = new THREE.Vector3(), center = new THREE.Vector3();
        box.getSize(size); box.getCenter(center);
        const maxDim = Math.max(size.x, size.y, size.z);
        // Tighten fit so the model appears ~1.75x larger
        const FIT_TIGHTNESS = 1.6 / 1.75;
        const dist = maxDim * FIT_TIGHTNESS / Math.tan((camera.fov * Math.PI / 180) / 2);
        const dir = new THREE.Vector3(1, 1, 1).normalize();
        camera.position.copy(center.clone().add(dir.multiplyScalar(dist)));
        camera.near = Math.max(0.01, dist / 100);
        camera.far = dist * 10 + maxDim;
        camera.updateProjectionMatrix();
        controls.target.copy(center);
        controls.update();
      }

      // Simple FPS meter (EMA smoothed)
      let __fpsLast = performance.now();
      let __fpsAccMs = 0;
      let __fpsFrames = 0;
      let __fpsEMA = 0;

      function render() {
        controls.update();

        // FPS update
        const now = performance.now();
        const dt = now - __fpsLast; __fpsLast = now;
        __fpsAccMs += dt; __fpsFrames += 1;
        if (__fpsAccMs >= 500) {
          const inst = (__fpsFrames * 1000) / __fpsAccMs;
          __fpsEMA = (__fpsEMA === 0) ? inst : (__fpsEMA * 0.8 + inst * 0.2);
          const el = document.getElementById('fpsValue');
          if (el) el.textContent = __fpsEMA.toFixed(1);
          __fpsAccMs = 0; __fpsFrames = 0;
        }

        // Main scene
        renderer.clear();
        renderer.setViewport(0, 0, renderer.domElement.width, renderer.domElement.height);
        renderer.setScissorTest(false);
        renderer.render(scene, camera);

        // Overlay axes (bottom-left) — only if enabled
        if (window.__showAxes__) {
          // Copy view rotation only by rotating the gizmo opposite the camera
          // so it reflects world-axis orientation in the current view.
          axisGizmo.quaternion.copy(camera.quaternion).invert();
          const size = new THREE.Vector2();
          renderer.getSize(size);
          const px = Math.max(64, Math.min(128, Math.floor(Math.min(size.x, size.y) / 5)));
          const margin = 10;
          renderer.clearDepth();
          renderer.setScissorTest(true);
          renderer.setScissor(margin, margin, px, px);
          renderer.setViewport(margin, margin, px, px);
          // Orthographic camera has fixed framing; no aspect update needed
          renderer.render(axisScene, axisCamera);
        }

        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);

      // --- UI wiring ---
      const fileInput = document.getElementById('fileInput');
      const openBtn = document.getElementById('openBtn');
      const fileSelect = document.getElementById('fileSelect');
      const isoInput = document.getElementById('iso');
      const opInput = document.getElementById('opacity');
      const posColor = document.getElementById('posColor');
      const negColor = document.getElementById('negColor');
      const bgColor = document.getElementById('bgColor');
      const toggleAtoms = document.getElementById('showAtoms');
      const toggleBonds = document.getElementById('showBonds');
      const elementColors = document.getElementById('elementColors');
      const toggleBox = document.getElementById('showBox');
      const toggleAxes = document.getElementById('showAxes');
      const saveBtn = document.getElementById('saveBtn');
      const batchBtn = document.getElementById('batchBtn');
      const surfBtn = document.getElementById('surfBtn');
      const clearBtn = document.getElementById('clearBtn');
      const helpBtn = document.getElementById('helpBtn');
      const editBtn = document.getElementById('editBtn');
      const editPanel = document.getElementById('editPanel');
      const editClose = document.getElementById('editClose');
      // Side panel controls
      const panelBtn = document.getElementById('panelBtn');
      const sidePanel = document.getElementById('sidePanel');
      const sideClose = document.getElementById('sideClose');
      const helpOverlay = document.getElementById('helpOverlay');
      const helpClose = document.getElementById('helpClose');
      const coordsContent = document.getElementById('coordsContent');
      const copyXYZBtn = document.getElementById('copyXYZ');
      const downloadXYZBtn = document.getElementById('downloadXYZ');
      const clearMoleculeBtn = document.getElementById('clearMolecule');
      // View controls
      const shiftX = document.getElementById('shiftX');
      const shiftY = document.getElementById('shiftY');
      const shiftZ = document.getElementById('shiftZ');
      const camX = document.getElementById('camX');
      const camY = document.getElementById('camY');
      const camZ = document.getElementById('camZ');
      const tgtX = document.getElementById('tgtX');
      const tgtY = document.getElementById('tgtY');
      const tgtZ = document.getElementById('tgtZ');
      const autoRot = document.getElementById('autoRot');
      const rotSpeed = document.getElementById('rotSpeed');
      const damp = document.getElementById('damp');
      const autoRotSpeed = document.getElementById('autoRotSpeed');
      const viewReset = document.getElementById('viewReset');
      const styleSelect = document.getElementById('styleSelect');
      const schemeSelect = document.getElementById('schemeSelect');
      const renderModeSel = document.getElementById('renderMode');
      const cloudTypeSel = document.getElementById('cloudType');
      const cloudStrideEl = document.getElementById('cloudStride');
      const cloudAlphaEl = document.getElementById('cloudAlpha');

      openBtn.onclick = () => fileInput.click();
      // Toggle surface rendering button
      const updateSurfBtn = () => { surfBtn.textContent = showSurfaces ? 'Hide Surfaces' : 'Show Surfaces'; };
      updateSurfBtn();
      surfBtn.onclick = () => { showSurfaces = !showSurfaces; updateSurfBtn(); rebuildScene({ preserveView: true }); };
      const toggleSide = () => { sidePanel.classList.toggle('open'); sidePanel.setAttribute('aria-hidden', sidePanel.classList.contains('open') ? 'false' : 'true'); };
      const closeSide = () => { if (sidePanel.classList.contains('open')) { sidePanel.classList.remove('open'); sidePanel.setAttribute('aria-hidden', 'true'); } };
      panelBtn.onclick = toggleSide;
      // Independent edit panel toggling
      function toggleEdit() { if (!editPanel) return; const show = editPanel.style.display !== 'flex' && editPanel.style.display !== 'block'; editPanel.style.display = show ? 'block' : 'none'; editPanel.setAttribute('aria-hidden', show ? 'false' : 'true'); }
      if (editBtn) editBtn.onclick = toggleEdit;
      if (editClose) editClose.onclick = toggleEdit;
      sideClose.onclick = toggleSide;
      const sideCloseEdit = document.getElementById('sideCloseEdit');
      if (sideCloseEdit) sideCloseEdit.onclick = toggleSide;
      // Help modal logic
      function openHelp() { helpOverlay.style.display = 'flex'; helpOverlay.setAttribute('aria-hidden', 'false'); }
      function closeHelp() { helpOverlay.style.display = 'none'; helpOverlay.setAttribute('aria-hidden', 'true'); }
      if (helpBtn) helpBtn.onclick = openHelp;
      if (helpClose) helpClose.onclick = closeHelp;
      if (helpOverlay) helpOverlay.addEventListener('click', (e) => { if (e.target === helpOverlay) closeHelp(); });

      if (clearMoleculeBtn) clearMoleculeBtn.onclick = () => {
        if (currentIndex < 0 || !volumes[currentIndex]) return;
        const vol = volumes[currentIndex].vol;
        if (!vol) return;
        vol.atoms = [];
        vol.bonds = [];
        rebuildScene({ preserveView: true });
        updateSidePanel();
      };

      // --- Edit UI elements ---
      const editEnableEl = document.getElementById('editEnable');
      const elemSelectEl = document.getElementById('elemSelect');
      const elemOtherBtn = document.getElementById('elemOther');
      const bondOrderEl = document.getElementById('bondOrder');
      const autoHydrogenEl = document.getElementById('autoHydrogen');
      const ptOverlay = document.getElementById('ptOverlay');
      const ptClose = document.getElementById('ptClose');
      const ptGrid = document.getElementById('ptGrid');
      const ptSearch = document.getElementById('ptSearch');
      function openPT() { if (ptOverlay) { ptOverlay.style.display = 'flex'; buildPT(''); } }
      function closePT() { if (ptOverlay) ptOverlay.style.display = 'none'; }
      function buildPT(query) {
        if (!ptGrid) return;
        const q = String(query || '').trim().toLowerCase();
        ptGrid.innerHTML = '';
        const data = (window.ATOM_DATA || []).filter(d => {
          if (!q) return true;
          return d.symbol.toLowerCase().includes(q) || (d.name||'').toLowerCase().includes(q);
        });
        for (const d of data) {
          const btn = document.createElement('button');
          btn.textContent = d.symbol;
          btn.style.cssText = 'padding:8px 6px; border-radius:6px; border:1px solid #223; background:#1a2230; color:var(--text); cursor:pointer;';
          btn.onclick = () => { selectedElement = d.symbol; selectedZ = symToZ(d.symbol); if (elemSelectEl) elemSelectEl.value = d.symbol; closePT(); };
          ptGrid.appendChild(btn);
        }
      }
      if (ptClose) ptClose.onclick = closePT;
      if (ptOverlay) ptOverlay.addEventListener('click', (e) => { if (e.target === ptOverlay) closePT(); });
      if (ptSearch) ptSearch.oninput = () => buildPT(ptSearch.value);
      if (elemSelectEl) { elemSelectEl.value = selectedElement; elemSelectEl.onchange = () => { selectedElement = elemSelectEl.value; selectedZ = symToZ(selectedElement); }; }
      if (elemOtherBtn) elemOtherBtn.onclick = () => openPT();
      if (bondOrderEl) bondOrderEl.onchange = () => { newBondOrderSetting = bondOrderEl.value; };
      if (autoHydrogenEl) autoHydrogenEl.onchange = () => { autoHydrogens = !!autoHydrogenEl.checked; };
      if (editEnableEl) editEnableEl.onchange = () => { editEnabled = !!editEnableEl.checked; controls.enabled = !editEnabled; };

      function refreshViewUI() {
        const notEditing = (el) => document.activeElement !== el;
        if (notEditing(shiftX)) shiftX.value = contentGroup.position.x.toFixed(3);
        if (notEditing(shiftY)) shiftY.value = contentGroup.position.y.toFixed(3);
        if (notEditing(shiftZ)) shiftZ.value = contentGroup.position.z.toFixed(3);
        if (notEditing(camX)) camX.value = camera.position.x.toFixed(3);
        if (notEditing(camY)) camY.value = camera.position.y.toFixed(3);
        if (notEditing(camZ)) camZ.value = camera.position.z.toFixed(3);
        if (notEditing(tgtX)) tgtX.value = controls.target.x.toFixed(3);
        if (notEditing(tgtY)) tgtY.value = controls.target.y.toFixed(3);
        if (notEditing(tgtZ)) tgtZ.value = controls.target.z.toFixed(3);
        autoRot.checked = controls.autoRotate === true;
        if (notEditing(rotSpeed)) rotSpeed.value = (controls.rotateSpeed ?? 1.0).toFixed(2);
        if (notEditing(damp)) damp.value = (controls.dampingFactor ?? 0.05).toFixed(2);
        if (notEditing(autoRotSpeed)) autoRotSpeed.value = (controls.autoRotateSpeed ?? 2.0).toFixed(2);
        // Edit UI
        if (editEnableEl) editEnableEl.checked = !!editEnabled;
        if (elemSelectEl && notEditing(elemSelectEl)) elemSelectEl.value = selectedElement;
        if (bondOrderEl && notEditing(bondOrderEl)) bondOrderEl.value = String(newBondOrderSetting);
        if (autoHydrogenEl) autoHydrogenEl.checked = !!autoHydrogens;
      }

      // Initialize view UI
      refreshViewUI();
      controls.addEventListener('change', refreshViewUI);

      // Reset view to the initial camera/target/shift
      viewReset.onclick = () => {
        if (defaultView) {
          contentGroup.position.copy(defaultView.contentPos);
          camera.copy(defaultView.cam);
          controls.target.copy(defaultView.target);
          controls.update();
          refreshViewUI();
        } else {
          fitCameraToScene();
          refreshViewUI();
        }
      };

      // Surface style selector
      if (styleSelect) {
        styleSelect.value = surfaceStyle;
        styleSelect.onchange = () => { surfaceStyle = styleSelect.value; rebuildScene({ preserveView: true }); };
      }

      // Default color schemes for +/- surfaces
      if (schemeSelect) {
        const schemes = {
          emory: { pos: '#f2a900', neg: '#0033a0' },
          national: { pos: '#e60000', neg: '#0033a0' },
          bright: { pos: '#ffcc00', neg: '#00bfff' },
          electron: { pos: '#ff00bf', neg: '#2eb82e' },
          classic: { pos: '#1f77b4', neg: '#d62728' },
        };
        schemeSelect.onchange = () => {
          const v = schemeSelect.value;
          const s = schemes[v];
          if (s) {
            posColor.value = s.pos;
            negColor.value = s.neg;
            updateOpacityAndColors();
          }
        };
      }

      // Render mode / cloud params
      let renderMode = (renderModeSel && renderModeSel.value) || 'surface';
      let cloudType = (cloudTypeSel && cloudTypeSel.value) || 'cubes';
      function updateRenderModeUI() {
        const isCloud = renderMode === 'cloud';
        const rowStyle = document.getElementById('rowStyle');
        const rowCloudType = document.getElementById('rowCloudType');
        const rowCloudParams = document.getElementById('rowCloudParams');
        if (rowStyle) rowStyle.style.display = isCloud ? 'none' : '';
        if (rowCloudType) rowCloudType.style.display = isCloud ? '' : 'none';
        if (rowCloudParams) rowCloudParams.style.display = isCloud ? '' : 'none';
      }
      function readCloudOpts() {
        const iso = Math.abs(parseFloat((isoInput && isoInput.value) || '0')) || 0;
        return {
          type: cloudType,
          stride: Math.max(1, parseInt((cloudStrideEl && cloudStrideEl.value) || '2', 10)),
          tLow: iso > 0 ? iso : 1e-6, // threshold tied to iso value
          alphaMax: Math.min(1, Math.max(0.05, parseFloat((cloudAlphaEl && cloudAlphaEl.value) || '0.05'))),
        };
      }
      if (renderModeSel) renderModeSel.onchange = () => { renderMode = renderModeSel.value; updateRenderModeUI(); rebuildScene({ preserveView: true }); };
      if (cloudTypeSel) cloudTypeSel.onchange = () => { cloudType = cloudTypeSel.value; rebuildScene({ preserveView: true }); };
      if (cloudStrideEl) cloudStrideEl.onchange = () => rebuildScene({ preserveView: true });
      if (cloudAlphaEl) cloudAlphaEl.onchange = () => rebuildScene({ preserveView: true });
      // Initialize UI visibility based on current mode
      updateRenderModeUI();

      // Axes gizmo state
      window.__showAxes__ = true;
      if (toggleAxes) toggleAxes.checked = !!window.__showAxes__;

      // Apply handlers
      const toNum = (v, def = 0) => { const n = parseFloat(v); return Number.isFinite(n) ? n : def; };
      for (const el of [shiftX, shiftY, shiftZ]) {
        el.oninput = () => {
          contentGroup.position.set(toNum(shiftX.value, 0), toNum(shiftY.value, 0), toNum(shiftZ.value, 0));
        };
      }
      for (const el of [camX, camY, camZ]) {
        el.oninput = () => {
          camera.position.set(toNum(camX.value, camera.position.x), toNum(camY.value, camera.position.y), toNum(camZ.value, camera.position.z));
          controls.update();
        };
      }
      for (const el of [tgtX, tgtY, tgtZ]) {
        el.oninput = () => {
          controls.target.set(toNum(tgtX.value, controls.target.x), toNum(tgtY.value, controls.target.y), toNum(tgtZ.value, controls.target.z));
          controls.update();
        };
      }
      autoRot.onchange = () => { controls.autoRotate = !!autoRot.checked; };
      rotSpeed.oninput = () => { const v = toNum(rotSpeed.value, 1.0); if (Number.isFinite(v)) controls.rotateSpeed = v; };
      damp.oninput = () => { const v = toNum(damp.value, 0.05); if (Number.isFinite(v)) controls.dampingFactor = v; };
      autoRotSpeed.oninput = () => { const v = toNum(autoRotSpeed.value, 2.0); if (Number.isFinite(v)) controls.autoRotateSpeed = v; };

      function updateSidePanel() {
        if (currentIndex < 0 || !volumes[currentIndex]) { coordsContent.innerHTML = '<em>No file loaded</em>'; return; }
        const v = volumes[currentIndex].vol;
        if (!v || !Array.isArray(v.atoms) || v.atoms.length === 0) { coordsContent.innerHTML = '<em>No atoms</em>'; return; }
        const rows = v.atoms.map((a, i) => {
          const z = a.Z | 0;
          const sym = (window.ATOM_Z_TO_DATA && window.ATOM_Z_TO_DATA[z] && window.ATOM_Z_TO_DATA[z].symbol) || String(z);
          const toAng = (v.units === 'angstrom');
          const x = toAng ? a.x : a.x * BOHR_TO_ANG;
          const y = toAng ? a.y : a.y * BOHR_TO_ANG;
          const zA = toAng ? a.z : a.z * BOHR_TO_ANG;
          return `<tr><td>${i + 1}</td><td>${sym}</td><td>${(a.Z | 0)}</td><td>${x.toFixed(3)}</td><td>${y.toFixed(3)}</td><td>${zA.toFixed(3)}</td></tr>`;
        }).join('');
        coordsContent.innerHTML = `
          <div style="margin-bottom:8px;color:var(--muted)">Active: ${volumes[currentIndex].name}</div>
          <table>
            <thead><tr><th>#</th><th>Sym</th><th>Z</th><th>x</th><th>y</th><th>z</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>`;
      }

      function toXYZString() {
        if (currentIndex < 0 || !volumes[currentIndex]) return '';
        const v = volumes[currentIndex].vol;
        if (!v || !Array.isArray(v.atoms)) return '';
        const atoms = v.atoms;
        const lines = [];
        lines.push(String(atoms.length));
        const comment = (v.title || volumes[currentIndex].name || '').toString();
        lines.push(comment);
        for (const a of atoms) {
          const z = a.Z | 0;
          const sym = (window.ATOM_Z_TO_DATA && window.ATOM_Z_TO_DATA[z] && window.ATOM_Z_TO_DATA[z].symbol) || String(z);
          const toAng = (v.units === 'angstrom');
          const x = toAng ? a.x : a.x * BOHR_TO_ANG;
          const y = toAng ? a.y : a.y * BOHR_TO_ANG;
          const zA = toAng ? a.z : a.z * BOHR_TO_ANG;
          lines.push(`${sym} ${x.toFixed(6)} ${y.toFixed(6)} ${zA.toFixed(6)}`);
        }
        return lines.join('\n');
      }

      copyXYZBtn.onclick = async () => {
        const txt = toXYZString();
        if (!txt) return;
        try {
          await navigator.clipboard.writeText(txt);
        } catch (e) {
          const ta = document.createElement('textarea');
          ta.value = txt; document.body.appendChild(ta); ta.select();
          try { document.execCommand('copy'); } catch { }
          document.body.removeChild(ta);
        }
      };

      downloadXYZBtn.onclick = () => {
        const txt = toXYZString();
        if (!txt) return;
        const blob = new Blob([txt], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const base = volumes[currentIndex] ? volumes[currentIndex].name.replace(/\.[^/.]+$/, '') : 'coords';
        a.download = `${base}.xyz`;
        a.href = url;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };

      async function handleFiles(fileList) {
        const arr = Array.from(fileList);
        // If demo is present and this is the first real load, clear it
        if (volumes.length === 1 && volumes[0].name === 'Demo Water') {
          console.log('[CUBE] Replacing demo with loaded file(s).');
          volumes = [];
          currentIndex = -1;
          clearSceneMeshes();
        }
        // Remove sample cube if present
        if (volumes.some(v => v.isSample)) {
          console.log('[CUBE] Removing sample.cube from list before adding user files.');
          volumes = volumes.filter(v => !v.isSample);
          currentIndex = -1;
          clearSceneMeshes();
        }
        const startIndex = volumes.length; // index of first newly added
        for (const f of arr) {
          const text = await f.text();
          const lower = f.name.toLowerCase();
          const vol = (lower.endsWith('.xyz')) ? parseXYZ(text) : parseCube(text);
          volumes.push({ name: f.name, vol });
          // adopt hinted iso if the user hasn’t interacted yet
          if (vol.isoHint != null && (isoInput.value === '' || currentIndex === -1)) {
            isoInput.value = String(vol.isoHint);
          }
          // Debug: print parsed volume info
          if (vol.data && vol.data.length) {
            try {
              const stats = arrayMinMax(vol.data);
              console.log('[CUBE] Loaded', f.name, { title: vol.title, nxyz: vol.nxyz, origin: vol.origin, axes: vol.axes, natoms: vol.natoms, isoHint: vol.isoHint, min: stats.min, max: stats.max });
            } catch (e) {
              console.warn('[CUBE] Stats failed for', f.name, e);
            }
          } else {
            console.log('[XYZ] Loaded', f.name, { natoms: vol.natoms });
          }
        }
        refreshFileSelect();
        if (volumes.length > 0) {
          // Select the first of the newly added files
          currentIndex = startIndex;
          if (fileSelect && fileSelect.options.length > currentIndex) {
            fileSelect.value = String(currentIndex);
          }
          rebuildScene();
          updateSidePanel();
        }
      }

      fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
      const drop = document.getElementById('drop');
      drop.addEventListener('dragover', e => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
      drop.addEventListener('drop', e => { e.preventDefault(); if (e.dataTransfer.files) handleFiles(e.dataTransfer.files); });
      // Close side panel when clicking on the scene (not during drags)
      let downPos = null;
      drop.addEventListener('pointerdown', (e) => {
        if (e.button === 0) downPos = { x: e.clientX, y: e.clientY };
        else downPos = null;
        if (!editEnabled) return;
        dragActive = false;
        createdStartAtomOnDown = false;
        // Begin edit interactions
        setNDCFromEvent(e);
        raycaster.setFromCamera(ndc, camera);
        // Try atoms first
        const atomHits = raycaster.intersectObjects(atomGroup.children, false);
        if (e.button === 0) {
          if (atomHits.length > 0) {
            const h = atomHits[0].object;
            if (h && h.userData && h.userData.type === 'atom') {
              // Start possible drag from existing atom; preview will appear once movement exceeds threshold
              dragFromAtom = h.userData.index;
              controls.enabled = false;
              return;
            }
          }
          // Not on an atom: create a new atom at the clicked point (on target plane), and prepare for drag
          const vol = (currentIndex >= 0 && volumes[currentIndex]) ? volumes[currentIndex].vol : null;
          if (vol && Array.isArray(vol.atoms)) {
            const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), controls.target.clone());
            const hit = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(plane, hit)) {
              const [x, y, z] = worldToAtomUnits(vol, hit);
              vol.atoms.push({ Z: selectedZ || symToZ(selectedElement), q: 0, x, y, z });
              dragFromAtom = vol.atoms.length - 1;
              createdStartAtomOnDown = true;
              // Show the newly created atom immediately
              rebuildScene({ preserveView: true });
              controls.enabled = false;
            }
          }
        }
      });
      drop.addEventListener('pointerup', (e) => {
        if (!downPos) return;
        const dx = e.clientX - downPos.x, dy = e.clientY - downPos.y;
        const moved = Math.hypot(dx, dy) > 4; // threshold to distinguish drag
        downPos = null;
        if (!moved && sidePanel.classList.contains('open')) closeSide();
        // Finish edit interactions
        if (editEnabled) {
          controls.enabled = !editEnabled;
          setNDCFromEvent(e);
          raycaster.setFromCamera(ndc, camera);
          const vol = (currentIndex >= 0 && volumes[currentIndex]) ? volumes[currentIndex].vol : null;
          if (vol && Array.isArray(vol.atoms)) {
            if (dragFromAtom != null) {
              // Finalize if there was an actual drag; otherwise treat as a click
              const a0 = atomUnitsToAng(vol, vol.atoms[dragFromAtom]);
              let targetIndex = dragSnapTo;
              let placePos = null;
              if (targetIndex == null && dragActive) {
                // Intersect plane through origin atom, normal camera dir
                const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), a0.clone());
                const hit = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, hit);
                placePos = hit.clone();
              }
              // cleanup preview
              if (dragGhost) { contentGroup.remove(dragGhost); dragGhost.geometry.dispose(); dragGhost.material.dispose(); dragGhost = null; }
              if (dragBond) { contentGroup.remove(dragBond); dragBond.geometry.dispose(); dragBond.material.dispose(); dragBond = null; }
              if (dragActive && targetIndex != null && targetIndex !== dragFromAtom) {
                const ai = dragFromAtom, aj = targetIndex;
                let order = 1;
                if (newBondOrderSetting === 'auto') {
                  const p1 = atomUnitsToAng(vol, vol.atoms[ai]);
                  const p2 = atomUnitsToAng(vol, vol.atoms[aj]);
                  order = computeBondOrderByLength(vol.atoms[ai].Z|0, vol.atoms[aj].Z|0, p1.distanceTo(p2));
                } else { order = parseInt(newBondOrderSetting, 10) || 1; }
                addBond(vol, ai, aj, order);
                if (autoHydrogens) { adjustHydrogens(vol, ai); adjustHydrogens(vol, aj); }
                rebuildScene({ preserveView: true });
              } else if (dragActive && placePos) {
                // Drag created a new atom and bond target
                const [x, y, z] = worldToAtomUnits(vol, placePos);
                const newAtom = { Z: selectedZ || symToZ(selectedElement), q: 0, x, y, z };
                vol.atoms.push(newAtom);
                const ai = dragFromAtom, aj = vol.atoms.length - 1;
                let order = 1;
                if (newBondOrderSetting === 'auto') {
                  const p1 = atomUnitsToAng(vol, vol.atoms[ai]);
                  const p2 = atomUnitsToAng(vol, newAtom);
                  order = computeBondOrderByLength(vol.atoms[ai].Z|0, newAtom.Z|0, p1.distanceTo(p2));
                } else { order = parseInt(newBondOrderSetting, 10) || 1; }
                addBond(vol, ai, aj, order);
                if (autoHydrogens) { adjustHydrogens(vol, ai); adjustHydrogens(vol, aj); }
                rebuildScene({ preserveView: true });
              } else if (!dragActive) {
                // No actual drag: treat as a simple click
                if (createdStartAtomOnDown) {
                  // We already placed a new atom on down; finalize H adjustment
                  const idx = dragFromAtom;
                  adjustHydrogens(vol, idx);
                  rebuildScene({ preserveView: true });
                } else {
                  // Clicked on existing atom: change element
                  const idx = dragFromAtom;
                  vol.atoms[idx].Z = selectedZ || symToZ(selectedElement);
                  if (autoHydrogens) { adjustHydrogens(vol, idx); }
                  rebuildScene({ preserveView: true });
                }
              }
              dragFromAtom = null; dragSnapTo = null;
              dragActive = false; createdStartAtomOnDown = false;
            } else {
              // Click without drag: atom change, bond cycle, or add atom in empty space
              // Try bond click
              const bondHits = raycaster.intersectObjects(bondGroup.children, false);
              if (bondHits.length > 0) {
                const obj = bondHits[0].object;
                if (obj.userData && obj.userData.type === 'bond') {
                  cycleBondOrder(vol, obj.userData.index);
                  rebuildScene({ preserveView: true });
                  return;
                }
              }
              // Try atom click
              const atomHits = raycaster.intersectObjects(atomGroup.children, false);
              if (atomHits.length > 0) {
                const obj = atomHits[0].object;
                if (obj.userData && obj.userData.type === 'atom') {
                  const idx = obj.userData.index;
                  vol.atoms[idx].Z = selectedZ || symToZ(selectedElement);
                  if (autoHydrogens) { addHydrogensIfNeeded(vol, idx); trimHydrogensIfExcess(vol, idx); }
                  rebuildScene({ preserveView: true });
                  return;
                }
              }
              // Else empty: place atom on target plane
              const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), controls.target.clone());
              const hit = new THREE.Vector3();
              if (raycaster.ray.intersectPlane(plane, hit)) {
                const [x, y, z] = worldToAtomUnits(vol, hit);
                vol.atoms.push({ Z: selectedZ || symToZ(selectedElement), q: 0, x, y, z });
                const idx = vol.atoms.length - 1;
                addHydrogensIfNeeded(vol, idx);
                rebuildScene({ preserveView: true });
              }
            }
          }
        }
      });
      drop.addEventListener('pointermove', (e) => {
        if (!editEnabled) return;
        setNDCFromEvent(e);
        raycaster.setFromCamera(ndc, camera);
        // Hover highlight
        const hoverHits = raycaster.intersectObjects(atomGroup.children, false);
        setHover(hoverHits.length > 0 ? hoverHits[0].object : null);

        const vol = (currentIndex >= 0 && volumes[currentIndex]) ? volumes[currentIndex].vol : null;
        if (!vol || dragFromAtom == null) return;
        const moved = downPos ? (Math.hypot(e.clientX - downPos.x, e.clientY - downPos.y) > 4) : true;
        if (!dragActive && moved) {
          dragActive = true;
          // Create preview assets lazily
          if (!dragGhost) {
            const ghostGeo = new THREE.SphereGeometry(0.4, 18, 10);
            const ghostMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
            dragGhost = new THREE.Mesh(ghostGeo, ghostMat);
            contentGroup.add(dragGhost);
          }
          if (!dragBond) {
            const bondGeo = new THREE.CylinderGeometry(0.08, 0.08, 1, 12);
            const bondMat = new THREE.MeshBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.7 });
            dragBond = new THREE.Mesh(bondGeo, bondMat);
            contentGroup.add(dragBond);
          }
        }
        const a0 = atomUnitsToAng(vol, vol.atoms[dragFromAtom]);
        // Try snap to other atom
        if (hoverHits.length > 0) {
          const h = hoverHits[0].object;
          if (h && h.userData && h.userData.type === 'atom') {
            const idx = h.userData.index;
            if (idx !== dragFromAtom) {
              dragSnapTo = idx;
              // Position preview bond to this atom; hide ghost
              const bPos = atomUnitsToAng(vol, vol.atoms[idx]);
              const mid = tmpV.copy(a0).add(bPos).multiplyScalar(0.5);
              const len = a0.distanceTo(bPos);
              if (dragBond) {
                dragBond.position.copy(mid);
                dragBond.scale.set(1, len, 1);
                dragBond.quaternion.setFromUnitVectors(tmpUp, tmpV.copy(bPos).sub(a0).normalize());
              }
              if (dragGhost) dragGhost.visible = false;
              return;
            }
          }
        }
        dragSnapTo = null;
        // Intersect plane through origin atom
        const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), a0.clone());
        const hit = new THREE.Vector3();
        raycaster.ray.intersectPlane(plane, hit);
        if (hit) {
          if (dragGhost) { dragGhost.visible = true; dragGhost.position.copy(hit); }
          const mid = tmpV.copy(a0).add(hit).multiplyScalar(0.5);
          const len = a0.distanceTo(hit);
          if (dragBond) {
            dragBond.position.copy(mid);
            dragBond.scale.set(1, len, 1);
            dragBond.quaternion.setFromUnitVectors(tmpUp, tmpV.copy(hit).sub(a0).normalize());
          }
        }
      });
      // Delete with right-click
      drop.addEventListener('contextmenu', (e) => {
        if (!editEnabled) return;
        e.preventDefault();
        setNDCFromEvent(e);
        raycaster.setFromCamera(ndc, camera);
        const vol = (currentIndex >= 0 && volumes[currentIndex]) ? volumes[currentIndex].vol : null;
        if (!vol) return false;
        const atomHits = raycaster.intersectObjects(atomGroup.children, false);
        if (atomHits.length > 0) {
          const obj = atomHits[0].object;
          if (obj.userData && obj.userData.type === 'atom') {
            removeAtom(vol, obj.userData.index);
            rebuildScene({ preserveView: true });
            return false;
          }
        }
        const bondHits = raycaster.intersectObjects(bondGroup.children, false);
        if (bondHits.length > 0) {
          const obj = bondHits[0].object;
          if (obj.userData && obj.userData.type === 'bond') {
            removeBond(vol, obj.userData.index);
            rebuildScene({ preserveView: true });
            return false;
          }
        }
        return false;
      });

      // Clear cubes and show sample again
      clearBtn.onclick = async () => {
        volumes = [];
        currentIndex = -1;
        refreshFileSelect();
        clearSceneMeshes();
        const ok = await loadSampleCube();
        if (!ok) loadDemo();
      };

      function refreshFileSelect() {
        fileSelect.innerHTML = "";
        volumes.forEach((v, i) => {
          const opt = document.createElement('option');
          opt.value = i; opt.textContent = v.name;
          fileSelect.appendChild(opt);
        });
        if (currentIndex >= 0) fileSelect.value = currentIndex;
      }

      fileSelect.onchange = () => {
        currentIndex = parseInt(fileSelect.value, 10);
        // Preserve camera view (position, orientation, zoom) when switching files
        rebuildScene({ preserveView: true });
        updateSidePanel();
      };

      // (subsample controls removed)

      isoInput.onchange = () => rebuildScene({ preserveView: true });
      opInput.oninput = updateOpacityAndColors;
      posColor.oninput = () => { if (typeof schemeSelect !== 'undefined' && schemeSelect) schemeSelect.value = 'custom'; updateOpacityAndColors(); };
      negColor.oninput = () => { if (typeof schemeSelect !== 'undefined' && schemeSelect) schemeSelect.value = 'custom'; updateOpacityAndColors(); };
      bgColor.oninput = () => {
        // Update scene background to selected color
        try { scene.background = new THREE.Color(bgColor.value); } catch { }
      };
      toggleAtoms.onchange = () => rebuildScene({ preserveView: true });
      toggleBonds.onchange = () => rebuildScene({ preserveView: true });
      elementColors.onchange = () => rebuildScene({ preserveView: true });
      toggleBox.onchange = () => rebuildScene({ preserveView: true });
      if (toggleAxes) toggleAxes.onchange = () => { window.__showAxes__ = !!toggleAxes.checked; };

      function rebuildScene(options = {}) {
        const preserveView = !!options.preserveView;
        // Save current camera + controls target if preserving view
        const savedCam = preserveView ? camera.clone() : null;
        const savedTarget = preserveView ? controls.target.clone() : null;
        if (currentIndex < 0) return;
        clearSceneMeshes();
        const vol = volumes[currentIndex].vol;

        // Compute robust min/max
        const { min, max } = arrayMinMax(vol.data || []);

        // Auto-iso fallback: if requested iso shows nothing, lower it to ~95th percentile of |field|
        let iso = parseFloat(isoInput.value || "0.02");
        if (!(max >= iso || min <= -iso)) {
          // compute ~95th percentile on a sampled subset for speed
          const sampleStep = Math.max(1, Math.floor(vol.data.length / 50000));
          const absVals = [];
          for (let i = 0; i < vol.data.length; i += sampleStep) absVals.push(Math.abs(vol.data[i]));
          absVals.sort((a, b) => a - b);
          const p95 = absVals[Math.floor(0.95 * (absVals.length - 1))] || 0.0;
          iso = p95 || Math.max(Math.abs(min), Math.abs(max)) * 0.5;
          console.warn('[CUBE] Requested iso produced no surface. Falling back to', iso.toFixed(6));
        }

        const opacity = parseFloat(opInput.value || "1.00");
        const posMat = createIsoMaterial('pos', opacity);
        const negMat = createIsoMaterial('neg', opacity);

        // Ensure bonds exist (for edit/xyz)
        if (Array.isArray(vol.atoms)) ensureBonds(vol);

        const hasGrid = Array.isArray(vol.nxyz) && (vol.nxyz[0] > 0 && vol.nxyz[1] > 0 && vol.nxyz[2] > 0);
        if (renderMode === 'surface' && showSurfaces && hasGrid) {
          // Positive iso (+iso value, + color)
          if (max >= iso) {
            const geomP = makeIsosurface(vol, iso);
            const meshP = new THREE.Mesh(geomP, posMat);
            meshP.userData.sign = 'pos';
            contentGroup.add(meshP); meshes.push(meshP);
            // Debug: triangle count
            if (geomP.index) console.log('[ISO+] triangles', (geomP.index.count / 3) | 0);
          }
          // Negative iso (−iso value, − color)
          if (min <= -iso) {
            const geomN = makeIsosurface(vol, -iso);
            const meshN = new THREE.Mesh(geomN, negMat);
            meshN.userData.sign = 'neg';
            contentGroup.add(meshN); meshes.push(meshN);
            if (geomN.index) console.log('[ISO-] triangles', (geomN.index.count / 3) | 0);
          }
        } else if (renderMode === 'cloud' && showSurfaces && hasGrid) {
          const opts = readCloudOpts();
          cloudGroup = (opts.type === 'points') ? buildCloudPoints(vol, opts) : buildCloudCubes(vol, opts);
          contentGroup.add(cloudGroup);
        }

        // Atoms
        if (toggleAtoms.checked) {
          atomGroup = buildAtoms(volumes[currentIndex].vol);
          contentGroup.add(atomGroup);
        }
        // Bonds
        if (toggleBonds.checked) {
          bondGroup = buildBonds(volumes[currentIndex].vol);
          contentGroup.add(bondGroup);
        }

        // Box
        if (toggleBox.checked && hasGrid) {
          boxHelper = buildBox(vol);
          contentGroup.add(boxHelper);
          console.log('[CUBE] Box helper added');
        }

        if (preserveView && savedCam && savedTarget) {
          camera.copy(savedCam);
          controls.target.copy(savedTarget);
          controls.update();
        } else {
          fitCameraToScene();
          if (!defaultView) {
            defaultView = {
              cam: camera.clone(),
              target: controls.target.clone(),
              contentPos: contentGroup.position.clone(),
            };
          }
        }
        console.log('[CUBE] Rebuilt scene. iso=', iso, 'opacity=', opacity, 'min/max=', min, max);
        updateSidePanel();
        clearHover();
      }

      function updateOpacityAndColors() {
        const op = parseFloat(opInput.value || "1.00");
        for (const m of meshes) {
          if (!m || !m.material) continue;
          const sign = m.userData && m.userData.sign;
          const colStr = sign === 'neg' ? negColor.value : posColor.value;
          const col = new THREE.Color(colStr);
          const mat = m.material;
          // Adapt behavior to glossy physical materials
          if (mat.isMeshPhysicalMaterial) {
            if (surfaceStyle === 'glass' && 'transmission' in mat) {
              // For glass: drive transmission with slider, keep alpha at 1
              col.multiplyScalar(2);
              mat.transmission = Math.max(0, Math.min(1, op));
              mat.color.copy(col);
            } else {
              // Emissive physical (default): use opacity, keep emissiveIntensity intact
              mat.opacity = op;
              mat.transparent = true;
              mat.color.copy(col);
              if (mat.emissive) mat.emissive.copy(col);
            }
          } else {
            // Fallback materials (standard/toon)
            mat.opacity = op;
            mat.transparent = true;
            mat.color.copy(col);
          }
          mat.needsUpdate = true;
        }
        // Update cloud colors as well
        if (cloudGroup && cloudGroup.children && cloudGroup.children.length) {
          for (const obj of cloudGroup.children) {
            const sign = obj.userData && obj.userData.sign;
            const colStr = sign === 'neg' ? negColor.value : posColor.value;
            if (!colStr) continue;
            if (obj.material) {
              const mat = obj.material;
              if (mat.isShaderMaterial && mat.uniforms && mat.uniforms.uColor) {
                mat.uniforms.uColor.value.set(colStr);
                mat.needsUpdate = true;
              } else if (mat.color) {
                mat.color.set(colStr);
                mat.needsUpdate = true;
              }
            }
          }
        }
      }

      saveBtn.onclick = () => {
        const link = document.createElement('a');
        const name = currentIndex >= 0 ? volumes[currentIndex].name.replace(/\.[^/.]+$/, '') : 'render';
        link.download = `${name}_iso${parseFloat(isoInput.value || "0.02").toFixed(4)}.png`;
        link.href = renderer.domElement.toDataURL('image/png');
        link.click();
      };

      batchBtn.onclick = async () => {
        if (volumes.length === 0) return;
        const keepCamera = camera.clone(); const keepTarget = controls.target.clone();

        for (let i = 0; i < volumes.length; i++) {
          currentIndex = i;
          fileSelect.value = i;
          rebuildScene();
          await new Promise(r => requestAnimationFrame(() => r()));
          const link = document.createElement('a');
          const name = volumes[i].name.replace(/\.[^/.]+$/, '');
          link.download = `${name}_iso${parseFloat(isoInput.value || "0.02").toFixed(4)}.png`;
          link.href = renderer.domElement.toDataURL('image/png');
          link.click();
          await new Promise(r => setTimeout(r, 120));
        }
        camera.copy(keepCamera); controls.target.copy(keepTarget); controls.update();
      };

      // Helpers to load the sample cube or demo
      async function loadSampleCube() {
        try {
          const resp = await fetch('./sample.cube', { cache: 'no-store' });
          if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
          const text = await resp.text();
          const vol = parseCube(text);
          volumes = [];
          currentIndex = -1;
          clearSceneMeshes();
          volumes.push({ name: 'sample.cube', vol, isSample: true });
          if (vol.isoHint != null && (isoInput.value === '' || currentIndex === -1)) {
            isoInput.value = String(vol.isoHint);
          }
          try {
            const stats = arrayMinMax(vol.data);
            console.log('[CUBE] Loaded sample.cube', { title: vol.title, nxyz: vol.nxyz, origin: vol.origin, axes: vol.axes, natoms: vol.natoms, isoHint: vol.isoHint, min: stats.min, max: stats.max });
          } catch (e) {
            console.warn('[CUBE] Stats failed for sample.cube', e);
          }
          currentIndex = 0;
          refreshFileSelect();
          rebuildScene();
          updateSidePanel();
          const hint = document.getElementById('hint');
          if (hint) hint.textContent = 'Loaded sample.cube • Orbit: mouse drag • Zoom: wheel • Pan: right-drag';
          return true;
        } catch (err) {
          console.warn('[CUBE] Could not auto-load sample.cube:', err);
          return false;
        }
      }

      function loadDemo() {
        const ANG_TO_BOHR = 1.0 / BOHR_TO_ANG;
        const r = 0.9572; // O–H bond length
        const theta = 104.5 * Math.PI / 180; // H–O–H angle
        const hx = r * Math.sin(theta / 2);
        const hz = r * Math.cos(theta / 2);
        const atoms = [
          { Z: (ATOM_SYMBOL_TO_Z.O || 8), q: 0, x: 0, y: 0, z: 0 },
          { Z: (ATOM_SYMBOL_TO_Z.H || 1), q: 0, x: hx * ANG_TO_BOHR, y: 0, z: hz * ANG_TO_BOHR },
          { Z: (ATOM_SYMBOL_TO_Z.H || 1), q: 0, x: -hx * ANG_TO_BOHR, y: 0, z: hz * ANG_TO_BOHR },
        ];
        const nx = 20, ny = 20, nz = 20;
        const step = 0.6; // Bohr per voxel along each axis
        const axes = [[step, 0, 0], [0, step, 0], [0, 0, step]];
        const origin = [-(nx * step) / 2, -(ny * step) / 2, -(nz * step) / 2]; // Bohr
        const data = new Float32Array(nx * ny * nz);
        const idx = (i, j, k) => (i * ny + j) * nz + k;
        const vol = { title: 'Demo Water', comment: '', natoms: 3, origin, nxyz: [nx, ny, nz], axes, atoms, data, idx, isoHint: null };
        volumes.push({ name: 'Demo Water', vol });
        currentIndex = 0;
        refreshFileSelect();
        rebuildScene();
        updateSidePanel();
      }

      // Startup: show sample cube, fallback to demo
      (async function initLoad() {
        if (volumes.length > 0) return;
        const ok = await loadSampleCube();
        if (!ok) loadDemo();
      })();

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        // Ignore shortcuts while typing in inputs
        const tag = (document.activeElement && document.activeElement.tagName) || '';
        const editing = tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
        if (e.key === 's' && !editing) saveBtn.click();
        if (e.key === 'b' && !editing) batchBtn.click();
        if ((e.key === 'i' || e.key === 'I') && !editing) { showSurfaces = !showSurfaces; if (typeof updateSurfBtn === 'function') updateSurfBtn(); rebuildScene({ preserveView: true }); }
        if ((e.key === 'x' || e.key === 'X') && !editing) {
          window.__showAxes__ = !window.__showAxes__;
          if (toggleAxes) toggleAxes.checked = !!window.__showAxes__;
        }
        if (!editing && (e.key === 'h' || e.key === 'H' || e.key === '?')) { if (helpOverlay && helpOverlay.style.display !== 'flex') openHelp(); else closeHelp(); }
        if (e.key === 'Escape') { closeSide(); if (helpOverlay) closeHelp(); }

        // Arrow keys: switch files (preserve camera)
        if (!editing && volumes.length > 0 && (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowUp')) {
          let delta = (e.key === 'ArrowRight' || e.key === 'ArrowDown') ? 1 : -1;
          const n = volumes.length;
          if (n > 0) {
            currentIndex = ((currentIndex + delta) % n + n) % n; // wrap safely
            if (fileSelect) fileSelect.value = String(currentIndex);
            rebuildScene({ preserveView: true });
            updateSidePanel();
            e.preventDefault();
          }
        }

        // Edit shortcuts: element symbols and bond order 1/2/3
        if (editEnabled && !editing) {
          const k = e.key;
          if (k === '1' || k === '2' || k === '3') {
            newBondOrderSetting = k;
            if (bondOrderEl) bondOrderEl.value = k;
          } else if (/^[a-zA-Z]$/.test(k)) {
            // Simple symbol capture: first letter uppercase, optional second collected briefly
            const first = k.toUpperCase();
            let sym = first;
            // Peek at next key within 500ms
            let handled = false;
            const onNext = (ev) => {
              if (handled) return;
              handled = true;
              window.removeEventListener('keypress', onNext, true);
              const kk = ev.key;
              if (/^[a-z]$/.test(kk)) { sym = first + kk; }
              selectedElement = sym; selectedZ = symToZ(selectedElement);
              if (elemSelectEl) elemSelectEl.value = selectedElement;
            };
            window.addEventListener('keypress', onNext, true);
            setTimeout(() => { if (!handled) { window.removeEventListener('keypress', onNext, true); selectedElement = sym; selectedZ = symToZ(selectedElement); if (elemSelectEl) elemSelectEl.value = selectedElement; } }, 500);
          }
        }
      });

    })();
  </script>
</body>

</html>
